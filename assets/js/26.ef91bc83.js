(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{414:function(t,a,e){"use strict";e.r(a);var v=e(28),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),e("p",[e("strong",[t._v("目录")])]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#列举-vue-的生命周期以及它们的应用场景"}},[t._v("列举 Vue 的生命周期以及它们的应用场景")])]),e("li",[e("a",{attrs:{href:"#父组件和子组件生命周期钩子执行顺序是什么"}},[t._v("父组件和子组件生命周期钩子执行顺序是什么？")])]),e("li",[e("a",{attrs:{href:"#dom-渲染在-vue-的哪个生命周期就已经完成"}},[t._v("DOM 渲染在 Vue 的哪个生命周期就已经完成")])]),e("li",[e("a",{attrs:{href:"#v-for-遍历模板时为什么要用-key-key-有什么用"}},[t._v("v-for 遍历模板时为什么要用 key? key 有什么用？")])]),e("li",[e("a",{attrs:{href:"#v-if-与-v-show-有什么区别-在什么场景下可以应用"}},[t._v("v-if 与 v-show 有什么区别? 在什么场景下可以应用")])]),e("li",[e("a",{attrs:{href:"#vue-组件通信"}},[t._v("vue 组件通信")])]),e("li",[e("a",{attrs:{href:"#vue-的双向绑定原理是什么"}},[t._v("vue 的双向绑定原理是什么？")])]),e("li",[e("a",{attrs:{href:"#怎么在组件中实现-v-modal"}},[t._v("怎么在组件中实现 v-modal")])]),e("li",[e("a",{attrs:{href:"#beforedestroy-一般的用途"}},[t._v("beforeDestroy 一般的用途")])]),e("li",[e("a",{attrs:{href:"#vue-router-的-beforeeach-和-aftereach-一般用法-使用场景"}},[t._v("vue router 的 beforeEach 和 afterEach 一般用法/使用场景?")])]),e("li",[e("a",{attrs:{href:"#虚拟-dom"}},[t._v("虚拟 DOM")])]),e("li",[e("a",{attrs:{href:"#vdom-diff-特点"}},[t._v("vdom diff 特点")])]),e("li",[e("a",{attrs:{href:"#vdom-diff-算法的事件复杂度"}},[t._v("vdom diff 算法的事件复杂度")])]),e("li",[e("a",{attrs:{href:"#vue-性能优化"}},[t._v("vue 性能优化")])]),e("li",[e("a",{attrs:{href:"#vue-如何监听-data-的每个属性变化"}},[t._v("vue 如何监听 data 的每个属性变化？")])]),e("li",[e("a",{attrs:{href:"#vue-模板引擎如何解析-指令如何处理-如何渲染为-html"}},[t._v("vue 模板引擎如何解析？指令如何处理？如何渲染为 HTML")])])])]),e("p"),t._v(" "),e("h2",{attrs:{id:"列举-vue-的生命周期以及它们的应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#列举-vue-的生命周期以及它们的应用场景"}},[t._v("#")]),t._v(" 列举 Vue 的生命周期以及它们的应用场景")]),t._v(" "),e("p",[t._v("Vue 的生命周期可以分为"),e("strong",[t._v("挂载阶段")]),t._v("、"),e("strong",[t._v("更新阶段")]),t._v("、"),e("strong",[t._v("销毁阶段")]),t._v("三大阶段。")]),t._v(" "),e("p",[t._v("TODO: 待补充...")]),t._v(" "),e("h2",{attrs:{id:"父组件和子组件生命周期钩子执行顺序是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父组件和子组件生命周期钩子执行顺序是什么"}},[t._v("#")]),t._v(" 父组件和子组件生命周期钩子执行顺序是什么？")]),t._v(" "),e("p",[t._v("TODO: 待补充...")]),t._v(" "),e("h2",{attrs:{id:"dom-渲染在-vue-的哪个生命周期就已经完成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom-渲染在-vue-的哪个生命周期就已经完成"}},[t._v("#")]),t._v(" DOM 渲染在 Vue 的哪个生命周期就已经完成")]),t._v(" "),e("p",[e("code",[t._v("mounted")]),t._v(" 就已经被挂载。")]),t._v(" "),e("h2",{attrs:{id:"v-for-遍历模板时为什么要用-key-key-有什么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-for-遍历模板时为什么要用-key-key-有什么用"}},[t._v("#")]),t._v(" v-for 遍历模板时为什么要用 key? key 有什么用？")]),t._v(" "),e("p",[t._v("必须要用 key，因为当列表刷新时，底层的虚拟 DOM 会使用 diff 算法来对比新旧 DOM 树的变化。它首先是比对同一层级的 "),e("code",[t._v("tag")]),t._v(" 和 "),e("code",[t._v("key")]),t._v(" 来判断是否是同一个节点(sameNode)，若同一个层级的列表项都设有唯一的 key 的话，那就可以避免重复渲染的问题，从而提升渲染性能。")]),t._v(" "),e("h2",{attrs:{id:"v-if-与-v-show-有什么区别-在什么场景下可以应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if-与-v-show-有什么区别-在什么场景下可以应用"}},[t._v("#")]),t._v(" v-if 与 v-show 有什么区别? 在什么场景下可以应用")]),t._v(" "),e("p",[t._v("主要取决于元素是否会多次渲染，"),e("code",[t._v("v-if")]),t._v(" 决定节点是否渲染，"),e("code",[t._v("v-show")]),t._v(" 会渲染节点，但会通过 "),e("code",[t._v("display")]),t._v(" 控制是否展示。")]),t._v(" "),e("p",[t._v("如果仅需渲染一次的话可以使用 "),e("code",[t._v("v-if")]),t._v("。反之，如果需要频繁渲染的话可以使用 "),e("code",[t._v("v-show")]),t._v(" 仅展示显隐。")]),t._v(" "),e("h2",{attrs:{id:"vue-组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件通信"}},[t._v("#")]),t._v(" vue 组件通信")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("父子通信中，父组件通过 "),e("code",[t._v("props")]),t._v(" 传值给子组件并监听子组件对应的事件，子组件通过 "),e("code",[t._v("emit")]),t._v(" 触发事件，")])]),t._v(" "),e("li",[e("p",[t._v("通过 vue 自定义事件进行父子/跨组件通信")]),t._v(" "),e("p",[t._v("详细的操作是： 先新建一个 "),e("code",[t._v("event.js")]),t._v(" 文件，该文件将导出一个新的 "),e("code",[t._v("Vue")]),t._v(" 实例，通过该实例进行收发事件。"),e("br"),t._v("\n如果在组件中使用 "),e("code",[t._v("event")]),t._v(" 监听了事件，那应该在组件销毁时，也就是 "),e("code",[t._v("beforeDestroy")]),t._v(" 中销毁该事件。")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("vuex")])])])]),t._v(" "),e("h2",{attrs:{id:"vue-的双向绑定原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-的双向绑定原理是什么"}},[t._v("#")]),t._v(" vue 的双向绑定原理是什么？")]),t._v(" "),e("p",[t._v("数据劫持，get set 发布者与订阅者")]),t._v(" "),e("p",[t._v("TODO: 待补充...")]),t._v(" "),e("h2",{attrs:{id:"怎么在组件中实现-v-modal"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么在组件中实现-v-modal"}},[t._v("#")]),t._v(" 怎么在组件中实现 v-modal")]),t._v(" "),e("p",[e("code",[t._v("v-model")]),t._v(" 默认会利用组件中名为 "),e("code",[t._v("value")]),t._v(" 的 "),e("code",[t._v("prop")]),t._v(" 和监听名为 "),e("code",[t._v("input")]),t._v(" 的事件 ("),e("code",[t._v("event")]),t._v(") 完成双向绑定。原理是: 当触发 "),e("code",[t._v("input")]),t._v(" 事件时，会将 "),e("code",[t._v("input")]),t._v(" 函数接收的值赋值给 "),e("code",[t._v("value")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-model")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 等同于 --\x3e")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":value")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("@input")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("name = $event.target.value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])]),e("p",[t._v("自定义组件可以设置 "),e("code",[t._v("model")]),t._v(" 来改变 "),e("code",[t._v("v-model")]),t._v(" 绑定的属性和方法。例如封装一个 "),e("code",[t._v("checkbox")]),t._v(" 组件, 它被选中的属性应该是 "),e("code",[t._v("checked")]),t._v(":")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("component")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'base-checkbox'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  model"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    prop"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'checked'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    event"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'change'")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  props"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    checked"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Boolean\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  template"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token template-string"}},[e("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('\n    <input\n      type="checkbox"\n      v-bind:checked="checked"\n      v-on:change="$emit(\'change\', $event.target.checked)"\n    >\n  ')]),e("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("h2",{attrs:{id:"beforedestroy-一般的用途"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#beforedestroy-一般的用途"}},[t._v("#")]),t._v(" beforeDestroy 一般的用途")]),t._v(" "),e("ul",[e("li",[t._v("解除自定义事件")]),t._v(" "),e("li",[t._v("消除定时器")]),t._v(" "),e("li",[t._v("解绑自定义的 DOM 事件监听器")])]),t._v(" "),e("h2",{attrs:{id:"vue-router-的-beforeeach-和-aftereach-一般用法-使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-的-beforeeach-和-aftereach-一般用法-使用场景"}},[t._v("#")]),t._v(" vue router 的 beforeEach 和 afterEach 一般用法/使用场景?")]),t._v(" "),e("p",[e("code",[t._v("beforeEach")]),t._v(" 可以从路由 "),e("code",[t._v("meta")]),t._v(" 中获取元数据来处理一些东西。比如在 "),e("code",[t._v("router meta")]),t._v(" 中设置 "),e("code",[t._v("title")]),t._v(" 的信息。还可以用于用户权限校验，当用户没有足够的权限访问目标页面的话，那就阻止页面跳转。")]),t._v(" "),e("p",[e("code",[t._v("afterEach")]),t._v(" 当页面切换后可以在此钩子将页面的滚动距离滚回顶部。")]),t._v(" "),e("h2",{attrs:{id:"虚拟-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),e("p",[t._v("因为 DOM 操作会非常耗费性能，因此引入了虚拟 DOM 来检查对 DOM 的操作。")]),t._v(" "),e("p",[t._v("引入虚拟 DOM 后，开发方式也发生了改变。以前需要手动操作 DOM，现在只需要关心数据的变化，由数据驱动视图。")]),t._v(" "),e("p",[t._v("虚拟 DOM 主要是指 "),e("code",[t._v("vdom")]),t._v(", 它用 js 生成 DOM 树来模拟 DOM 结构，计算出最小的变更来操作 dom。")]),t._v(" "),e("p",[t._v("计算最小的变更是通过 "),e("code",[t._v("diff 算法")]),t._v(" 来实现的，它也是 vdom 中最核心、最关键的部分。我们常说的 "),e("code",[t._v("vdom diff")]),t._v(" 其实 diff 新旧树的变化。")]),t._v(" "),e("h2",{attrs:{id:"vdom-diff-特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vdom-diff-特点"}},[t._v("#")]),t._v(" vdom diff 特点")]),t._v(" "),e("ul",[e("li",[t._v("vdom diff 只 diff 同一层，不跨级比较")]),t._v(" "),e("li",[t._v("tag 不相同，则直接丢掉重建，不再深度比较")]),t._v(" "),e("li",[t._v("tag 和 key，两者都相同，则认为是相同节点，不再深度比较")])]),t._v(" "),e("h2",{attrs:{id:"vdom-diff-算法的事件复杂度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vdom-diff-算法的事件复杂度"}},[t._v("#")]),t._v(" vdom diff 算法的事件复杂度")]),t._v(" "),e("p",[t._v("在 "),e("code",[t._v("O(n^3)")]),t._v(" 的基础上使用了同层比较策略，因此优化为 "),e("code",[t._v("O(n)")]),t._v(".")]),t._v(" "),e("h2",{attrs:{id:"vue-性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-性能优化"}},[t._v("#")]),t._v(" vue 性能优化")]),t._v(" "),e("p",[t._v("在使用层面上需要注意以下几点:")]),t._v(" "),e("ul",[e("li",[t._v("根据业务场景合理的使用 "),e("code",[t._v("v-if")]),t._v(" 和 "),e("code",[t._v("v-show")])]),t._v(" "),e("li",[t._v("合理使用 "),e("code",[t._v("computed")])]),t._v(" "),e("li",[e("code",[t._v("v-for")]),t._v(" 循环时加上唯一的 "),e("code",[t._v("key")]),t._v(", 避免和 "),e("code",[t._v("v-if")]),t._v(" 同时使用")]),t._v(" "),e("li",[t._v("在组件内创建的自定义事件、DOM 事件监听器在组件销毁前要销毁，避免内存泄露。")]),t._v(" "),e("li",[t._v("根据业务场景合理使用 "),e("code",[t._v("keep-alive")])]),t._v(" "),e("li",[t._v("data 层级不易过深")])]),t._v(" "),e("h2",{attrs:{id:"vue-如何监听-data-的每个属性变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-如何监听-data-的每个属性变化"}},[t._v("#")]),t._v(" vue 如何监听 data 的每个属性变化？")]),t._v(" "),e("p",[t._v("TODO: 待补充...")]),t._v(" "),e("h2",{attrs:{id:"vue-模板引擎如何解析-指令如何处理-如何渲染为-html"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-模板引擎如何解析-指令如何处理-如何渲染为-html"}},[t._v("#")]),t._v(" vue 模板引擎如何解析？指令如何处理？如何渲染为 HTML")]),t._v(" "),e("p",[t._v("TODO: 待补充...")]),t._v(" "),e("h1",{attrs:{id:"vue-与-react-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-与-react-的区别"}},[t._v("#")]),t._v(" Vue 与 React 的区别")]),t._v(" "),e("blockquote",[e("p",[t._v("如果候选者 vue 和 react 都开发过项目的话，面试官可能会问两者的差别，技术选型的理由")])]),t._v(" "),e("ol",[e("li",[t._v("在语法层面上 React 使用 JSX，Vue 使用模板。")]),t._v(" "),e("li",[t._v("在编程思想上，React 是函数式编程，vue 是声明式编程")]),t._v(" "),e("li",[t._v("React 相比 vue 会更精简，同时学习成本会更高一些。vue 的语法糖和封装程度比 React 高。比如 vue 原生的 "),e("code",[t._v("watch")]),t._v("、"),e("code",[t._v("keep-alive")]),t._v(" 等功能都需要 React 用户自己去实现，而 "),e("code",[t._v("vue")]),t._v(" 可以只关注使用。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);