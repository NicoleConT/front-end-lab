---
sidebarDepth: 3
---

# 2020

分享 2020 秋季所碰到的面试题。

<details open block>
<summary>折叠/展开目录</summary>

[[toc]]

</details>

## html

### 把带 css 链接的 link 标签放在 head 标签内，而带 js 链接的 script 标签尽量靠近 body, 为什么会有这种提议？如果必须不这样做，该如何处理？

HTML 解析是自上向下解析的。若在 `<head>` 中解析到 `<link>` 标签的话，可以一边加载样式表渲染样式，一边继续向下解析。

若解析到 `<script>` 标签的话，由于 `<script>` 有可能会修改 DOM 的结构(比如 `document.write()`)，因此会停止渲染，先将 `<script>` 加载完毕并执行后，才继续向下解析。在这阻塞的过程中，用户所看到的页面将是一片空白，会影响用户体验。所以早期最佳实践就是将 `<script>` 放到 `</body>` 之前，这样就不会影响页面的渲染了。

HTML5 为 `<script>` 引入了 `async` 属性，添加该属性后可使脚本请求并行加载，让尽快解析和执行而不阻塞渲染。常见的应用场景就是没有 `DOM` 依赖关系或是没有跟其他脚本有依赖关系的脚本，如页面统计等。

## css

### 列举水平垂直居中的实现

[CSS 居中元素实现示例](../css/README.md##layout-%e5%b1%85%e4%b8%ad%e5%85%83%e7%b4%a0)

### 计算样式权重

已知设备 IPhone6, 写出 div 最后的 color、font-size 值:

``` html
<style>
  div { font-size: 1rem; color: blue; }
  .class1 { font-size: .32rem; color: red; }
  #id1 { color: #333; }
  #id1 div { color: #666; }
  .class1 div { color: #999; }
  .class1 .class2 div { color: #aaa; }
</style>

<div class="class1">
    <div id="id1" class="class2">
        <div>文字</div>
    </div>
</div>
```

**答:** 从 DOM 的结构来看共有三层，各层实际被应用的样式为:

- 第一层: `font-size: .32rem`, `color: red`
- 第二层: `font-size: 1rem`, `color: #333`
- 第三层(含文字那层): `font-size: 1rem`, `color: #666`

CSS 选择器优先级:

| 优先级 | 权重   | 类型                                                                                      |
| ------ | ------ | ----------------------------------------------------------------------------------------- |
| 0 级   | 0      | 通配符(`*`)、选择符(`+`、`>`、`~`、`||`、空格等)、逻辑组合伪类(`:not`、`:is()`、`:where`) |
| 1 级   | 1      | 标签选择器，如 `body {...}` 等                                                            |
| 2 级   | 10     | 类选择器(`.list {...}`)、属性选择器(`body] {...}`)、伪类(`:hover`)                        |
| 3 级   | 100    | ID选择器(`#title {...}`)                                                                  |
| 4 级   | 内联级 | `style` 属性内联: `<span style=" color: red;" />`                                         |
| 5 级   | 顶级   | 添加 `!important` 规则： `.title { color: red !important; }`                              |

样式覆盖规则:

- 相同权重的样式，应用最后声明的样式
- 多个选择器则叠加权重，如: `.list > .item {...}` 的权重为 `10 + 0 + 10 = 20`。
- `style` 内联样式默认覆盖外部样式表的样式。除非内联样式设置了普通样式，而外部样式表的样式使用了 `!important` 规则的情况就无法覆盖。但也可以在 `style` 设置的样式属性中加上 `!important` 规则，叠加后权重就更高了(一般不推荐使用 `!important`)

## JavaScript

### 数组去重

1. 利用 `Set` 结构不可重复的特性

   ``` js
   var info = { name: 'anran758' };
   var arr = [0,1,2,2,info,3,info];

   // 通过扩展运算符将 Set 转为 Array
   var newArr = [...new Set(arr)];

   // 或者使用 Array.from 转为 Array
   var newArr = Array.from(new Set(arr));
   ```

   > 优点: 语法简洁
   > 缺点: Set 添加新值时是通过 [SameValueZero](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero) 算法进行比对的, 因此不能做深比较去重

2. 使用 `indexOf` 判断是否具有相同的项

   ``` js
   var info = { name: "anran758" };
   var arr = [0, 1, 2, 2, info, 3, info];

   function uniq(arr) {
     if (!arr || !arr.length) return [];

     var newArr = [];
     for (let i = 0; i < arr.length - 1; i++) {
       var item = arr[i];

       if (newArr.indexOf(item) === -1) {
         newArr.push(item);
       }
     }

     return newArr;
   }

   var newArr = uniq(arr);
   ```

   > 优点: 兼容低版本 IE
   > 缺点: 没有实现深比较去重

3. 引入 [loadsh](https://www.lodashjs.com/docs/lodash.uniq) 工具库来处理:
  
   ``` js
   var arr = [0, 2, 4, 3, 3, 2, 6];

   _.uniq(arr);
   ```

   还可以使用 [uniqWith](https://www.lodashjs.com/docs/lodash.uniqWith) 搭配 [isEqual](https://www.lodashjs.com/docs/lodash.isEqual) 实现深比较去重的效果。

   ``` js
   var objects = [
     { 'x': 1, 'y': 2 },
     { 'x': 2, 'y': 1 },
     { 'x': 1, 'y': 2 }
   ];

   _.uniqWith(objects, _.isEqual);
   // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
   ```

   > 优点: 语法简洁，使用方便，能满足所有去重需求
   > 缺点: 需要额外引入第三方库

### 数组多层扁平化

1. `Array.flat`: 数组的 `flat` 方法接受一个数值参数，该参数是指定需要扁平化的层数。若想将数组子项中所有数组进行扁平化，可以传入 `Infinity`。

   只扁平化第 1 层:

   ``` js
   var arr = [0, [1, [2], [[3]]], [[], 4]];
   arr.flat(1);
   // [0, 1, [2], [[3]], [], 4]
   ```

   全部扁平化:

   ``` js
   arr.flat(Infinity);
   // [0, 1, 2, 3, 4]
   ```

2. 通过递归的方式处理:

   ``` js
   var arr = [0, [1, [2], [[3]]], [[], 4]];

   function flatDeep(arr, depth) {
     var d = depth != null ? depth : 1;
     return d > 0
       ? arr.reduce((acc, val) =>
         acc.concat(Array.isArray(val)
           ? flatDeep(val, d - 1)
           : val),
         [])
       : arr.slice();
   }

   flatDeep(arr, 1);
   // [0, 1, [2], [[3]], [], 4]

   flatDeep(arr, Infinity);
   // [0, 1, 2, 3, 4]
   ```

   递归实现有很多思路，`reduce` 循环合并是一种，`for` 循环也是一种。它们只是实现细节不同，但递归思想是相通的。

### 深拷贝数组和对象

1. 可以先通过 `JSON.stringify` 将数据转为 JSON 字符串，再通过 `JSON.parse` 对 JSON 字符串进行解析，可以得到全新的数组/对象。  

   使用该方法进行深拷贝并不算完美，`JSON.stringify` 只能序列化对象的可枚举属性，如果对象是通过构造函数生成的，那么会丢失 `constructor`。也不能对有循环引用的对象进行深拷贝。  
   除此之外，`Date` 对象会被序列化为字符串。正则表达式、`Error` 对象会被序列化为空对象。若属性中存在 `undefined` 则该属性会被丢弃。`NaN`、`Infinity` 等信息会被转为 `null`。  
   由此可见，如果被拷贝的参数中没有 `Date`、正则、函数或对象循环引用的问题，可以考虑使用该方法。

2. 可以自己定义递归函数，参数是传入数组或对象。再遍历形参的属性或下标，如果遍历到的类型也是引用类型那就进行浅拷贝，再进行递归，直至全部属性都遍历完毕。
3. 通过第三方类库实现，如 `lodash` 的 `deepClone` 就可以实现深拷贝。

### 数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？

**A:** 取元素的复杂度为 `O(1)`, 消耗时间几乎一致，差异可以忽略不计。

### 数组的 map 和 forEach 有什么区别？

`map` 将每一个元素传入函数调用后，会将函数的返回值存入新数组中，因此可以对数组做链式处理。而 `forEach` 只是将元素传入给函数调用，不会讲返回值存入新数组中。

可以参考这个回答: [js es6 中如何比较深刻的理解 map、for、for of？](https://www.zhihu.com/question/278332594/answer/886056097)

### Fetch 与 XHR 的区别?

- `Fetch` 是基于 `Promise` 实现的, 相比 `XHR(XMLHttpRequest)` 的语法更加简洁。
- `Fetch` 发送请求时默认不带 `cookie` 的, 需要设置 `credentials` 的配置项
- 当接收到一个代表错误的 `HTTP` 状态码时, 从 `fetch()` 返回的 `Promise` 不会被标记为 `reject`, 即使响应的 `HTTP` 状态码是 `404` 或 `500`。仅当网络故障时或请求被阻止时, 才会标记为 `reject`。
- `Fetch` 不支持超时控制与检测请求进度

### bind、call、apply 的区别?

调用 bind 方法后返回一个新函数，新函数的 this 将被指向调用 bind 方法时的第一个参数。而其余参数将作为新函数的参数，供调用时使用

call 与 apply 第一个参数也是指定的 this 值，其余的不同是接受参数的不同。call 接受**参数列表**，apply 接收的是**参数数组**。两者相比，call 的性能会更好。

### 如何检测变量的类型(尽可能多，描述可能出现的问题)?

主要使用 `typeof`、`instantof`、`Object.prototype.toString.call`。还可以使用 `Array.isArray` 方法判断是否是数组，`Number.isNaN` 是否是 `NaN` 等。

`typeof` 可以用于 `String`、`Number`、`Symbol`、`Boolean`、`undefined` 等类型，但用于 `null`、`Array` 类型的话会展示为 `object` 类型。

`instanceof` 则是通过原型链的方式来判断对象类型。但它的局限性在于只要被操作的变量原型有上有该类型的值。它主要缺点是不能检测 `number`, `boolean`, `string` 字面量的类型。

`Object.prototype.toString.call` 可以精准的判断类型的值，主要的问题是写法繁琐，可以基于此函数做一层封装:

``` js
function getBaseType(target) {
  const typeStr = Object.prototype.toString.call(target).toLocaleLowerCase();

  return typeStr.slice(8, -1);
}
```

### 简述一下原型链 <Badge text="TODO" type="warning"/>

TODO: 待补充...

### 使用过 ES6 吗？你常用的有哪一些？

- let/const 自身特性与块级作用域
- 模板字符串
- 解构赋值
- 函数默认参数
- 箭头函数
- Promise
- async/await

### 简述一下 Promise 的特点

- 主要用于异步计算.
- 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。
- 可以在对象之间传递和操作 Promise，帮助我们处理队列。
- 链式写法更简洁，可以避免回调地狱

### Promise 怎么做异常处理?

1. Promise 最末尾添加 catch() 是统一 catch 错误
2. Promise.then 的第二个参数捕获错误

衍生问题:

**Q: `try...catch` 可以捕获 Promise.reject 错误吗，具体说说原因？**  

A: `try...catch` 是同步代码，而 `Promise`、`setTimeout` 等语句是异步代码，因此当异步代码发生错误时，`try...catch` 代码块已经执行完毕了，因此被抛出错误。

### Promise 串联加载?

1. 通过 async await ，等异步函数执行完毕取出 Promise 中的值
2. 通过 then 链式传递串联

### Promise 并行加载?

可以使用 `Promise.all`。

`Promise.all` 接受一个数组，数组内可以是对象、数组或者字符串等基本类型，也可以是 `Promise` 类型。

若数组中有 `Promise` 类型，当所有 `Promise` 的状态都变为成功后，就会进入 `Promise.all` 的 then 方法中，若有一项 `Promise` 状态变为 `reject`，则 `Promise.all` 的状态变为 `reject`。

### Promise 限流并发? <Badge text="TODO" type="warning"/>

TODO: 待补充...

### async/await?

- async/await 是最直接的同步写法，在也没有回调函数
- async/await 使用了 Promise，并没有和 Promise 产生冲突
- 但还是改变不了 js 单线程、异步的本质

### 一定要使用 async/await 吗，如果我不做异步处理，可能只是处理简单的关闭弹框不能用 Promise 吗?

这个问题没有标准答案，这个提问的目的是主要看你自己的见解或看法。面试官倾向非异步请求可以通过 Promise 处理，异步请求可以使用 async/await 处理，将使用用途区分开。

### 事件循环 (event-loop) <Badge text="TODO" type="warning"/>

1. 什么是单线程？和异步有什么关系？

   > TODO: 待补充...

1. 什么是事件循环

   js 是一个单线程非阻塞的语言，单线程意味着所有任务都要排队。但有一些任务耗时很长，js 引擎不想因为这些耗时长的任务而阻塞后面任务的处理。因此将这些任务分为**同步任务**与**异步任务**。

   事件循环中的任务又区分宏任务(Microtasks)与微任务(task)。两种任务各有一个任务队列。首先会执行微任务，然后再执行宏任务。

   > TODO: 待补充...

1. `setTimeout` 是否有误差？若有，产生误差的原因是什么？

   零延迟并不意味着回调会立即执行，其等待的时间取决于队列里待处理的消息数量。

1. 以下程序依次输出的信息是:

   ``` js
   (function() {

     console.log('这是开始');

     setTimeout(function cb() {
       console.log('这是来自第一个回调的消息');
     });

     console.log('这是一条消息');

     setTimeout(function cb1() {
       console.log('这是来自第二个回调的消息');
     }, 0);

     console.log('这是结束');

   })();

   // "这是开始"
   // "这是一条消息"
   // "这是结束"
   // "这是来自第一个回调的消息"
   // "这是来自第二个回调的消息"
   ```

### 计算题

1. 按顺序写出程序的输出结果:

   > 考察 this 问题

   ``` js
   var length = 10;

   function fn() { alert(this.length); }
   var obj = {
     length: 5,
     callApi: function(fn) {
       fn();
       arguments[0]();
     }
   }

   obj.callApi(fn, 3)
   ```

   该段代码依次输出 `10`、`2`。**函数的调用方式决定了 `this` 的值**。第二个函数调用是通过 `arguments` 调用，那么 `this` 自然指向 `arguments`，那 `arguments` 的实参有 `fn` 跟 `3` 两个参数，因此输出 `2`。

2. 列出下面代码的不足及优化方案

   > 考察事件代理与 nodeList

    ``` js
    var node = document.querySelectorAll('ul');
    for (var i = 0;i < node.length; i++) {
      node[i].addEventListener('click', function() {
        alert('click' + i);
      });
    }
    ```

3. 改造下面的代码，使之输出 0 ~ 9，写出你能想到的所有解法。

   ``` js
   for (var i = 0;i < 10; i++) {
     setTimeout(() => {
       console.log(i)
     }, 1000);
   }
   ```

   1. `var` 改为 `let`
   2. 循环体内的代码改为立即执行函数，利用闭包来修复

      ``` js
      for (var i = 0;i < 10; i++) {
        ((j) => {
          setTimeout(() => {
            console.log(j);
          }, j * 1000 );
        })(i);
      }
      ```

   3. 将循环体内的代码封装到新函数中，在循环体中调用该函数并传入 `i`
   4. 将 `i` 作为 `setTimeout` 内部函数的额外参数传入

       ``` js
       for (var i = 0;i < 10; i++) {
            setTimeout((j) => {
            console.log(j);
          }, 1000, i);
        }
       ```

4. 请写出下面代码的运行结果

   ``` js
   async function async1() {
    console.log("async1 start");
    await async2();
    console.log("async1 end");
   }

   async function async2() {
       console.log("async2");
   }

   console.log("script start");

   setTimeout(() => {
       console.log('setTimeout');
   }, 0);

   async1();

   new Promise((reslove) => {
       console.log("promise1");
       reslove();
   }).then(() => {
       console.log("promise2");
   })

   console.log("script end");
   ```

   依次输出的是:

   - script start
   - async1 start
   - async2
   - promise1
   - script end
   - async1 end
   - promise2
   - setTimeout

5. 下面的代码会进入 `.catch` 吗？解释一下你的答案。

   ``` js
   new Promise(() => {
     setTimeout(() => {
       throw new Error("Whoops!");
     }, 1000);
   }).catch(() => console.log("catched!"));
   ```

   A: 不会进入 `.catch`, 因为 `try...catch` 无法捕获异步代码的错误。

## 概念类

### 什么是闭包？列举闭包的应用场景

闭包主要指一个函数及其周围封闭词法环境中的引用构成闭包，这也是一种语言特性。从实践的角度来看，满足以下两个条件的才能称为闭包:

1. 创建该函数的上下文被销毁了，但该函数仍然存在
2. 函数内有引用外部变量

常见的应用场景是，在一个函数的局部作用域中创建一个内部函数，再将这个内部函数返回出去。
内部函数总是可以访问创建它的上下文，也就是外部函数中声明的参数和变量，即使创建内部函数的上下文已经销毁。例如:

``` js
function createName(name) {
  let prefix = "dvelopment_";
  return function showName() {
    console.log(prefix + name);
  };
}

var showName = createName('anran758');
showName();
```

调用 `createName` 后返回了一个函数并赋值给了 `showName` 变量，同时 `createName` 的上下文被销毁。
此时再调用 `showName` 函数时，尽管 `createName` 的上下文已经被销毁了，但 `showName` 中还能获取 `createName` 的内部变量与形参，这就是闭包的一种应用。

### 什么是科里化？

柯里化是一种将**使用多个参数的函数**转换成一系列**使用一个参数的函数**的技术，本质上也是利用了闭包的特性。科里化可以做到**参数复用**和**延迟执行**的效果。

例如，若传入了给定函数的所定义的参数数量后执行函数:

``` js
function add(a, b, c) { return a + b + c; }

function curry(fn, ...rest) {
  return fn.length !== rest.length
    ? function wrap(...args) {
      return rest.length + args.length !== fn.length
        ? (...arg) => wrap(...args, ...arg)
        : fn(...rest, ...args)
    }
    : fn(...rest)
}

curry(add)(1)(2)(3);
// 6
```

### 节流与防抖

- 函数节流(Throttle)是：在固定的时间内触发事件，每隔 n 秒只触发一次 (例子: 移动端下拉页面)
- 函数防抖是：当你频繁触发后，n 秒内只执行一次 (例子: window.resize 触发事件，通过防抖只更新最后一次事件)

### 说说从浏览器地址栏输入 URL 到页面加载完的过程中都发生了什么事情?

[从浏览器地址栏输入 URL 到页面渲染之间都经历了什么](https://zhuanlan.zhihu.com/p/95904514)

### 什么是纯函数

纯函数由三大原则构成：

1. 给定相同输入，它总是返回相同的输出
2. 过程没有副作用(side effect)
3. 没有额外的状态依赖

### 谈谈对 MVVM 的理解 <Badge text="TODO" type="warning"/>

TODO: 待补充...

## TypeScript

### 为什么要引入 TypeScript，引入的好处是什么？

TypeScript 是 JavaScript 的超集，在 JavaScript 的基础上引入了类型约束。

- 提供类型系统：增强了代码的可读性和可维护性，在编译阶段就能发现大部分错误
- 支持 ES6
- 强大的 IDE 支持: 类型检测、语法提示

## 优化类

### SPA（vue/react） 如何优化首页的加载速度？首屏空白是什么问题引起的？ <Badge text="TODO" type="warning"/>

最佳解决方案是使用服务端渲染来解决首屏空白的问题。

首屏空白主要出现在单页面应用 (SPA) 上，SPA 本质上是将页面的逻辑都存入了 js 中。浏览器会先加载 HTML 文档，再通过 HTML 文档下载包含页面逻辑的 js 文件，下载后还得执行 js 代码，再将页面渲染出来。

TODO: 待补充...

### 页面性能优化有哪些方案？

1. **尽可能减少 HTTP 请求**：CSS spirit 合并图片，小文件转为 Base64，合并 css/javascript 文件。
2. **使用 CDN**：CDN就是内容分发网络, 简单地说就是用户可以从最优的节点获取速度，从而达到快速访问，并减少源站负载压力的目的。
3. **减少 DNS 请求**
4. **文件/模块复用**
5. **按需加载**
6. **虚拟化长列表**: 过长的列表(成百上千条数据)会造成页面渲染压力大，因此可以使用 “虚拟滚动技术”。它可以在有限的事件内进渲染有限的内容，从而降低重新渲染组件所耗费的事件，以及创建 DOM 节点的数量。

## 解决方案

### 列举移动端适配方案

1. `rem`
2. `vw`/`vh`
3. 响应式 (`media query` 等)

### 怎么处理跨域？

- 前端开发时可使用 webpack devserve 进行代理
- jsonp
- nginx

## HTTP

### 列举 HTTP 状态码以及它们的含义

下面列举 web 开发中常见的 HTTP code:

- 200 (ok): 请求成功
- 204 (No Content): 请求成功，不需要附带实体内容 (body)
- 301 (Moved Permanently): 永久重定向。被请求的资源已永久移动到新位置
- 302 (Found): 临时重定向。请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。
- 400 (Bad Request): 请求参数有误
- 401 (Unauthorized): 当前请求需要用户验证
- 403 (Forbidden): 没有权限的操作。服务器已经理解请求，但拒绝执行。
- 404 (Not Found): 资源没有找到
- 500 (Internal Server Error): 服务端出现了错误
- 502 (Bad Gateway): 网关错误。此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应
- 503 (Service Unavailable): 服务器停止服务。常见原因是服务器因维护或重载而停机
- 504 (Gateway Timeout): 网关超时。当服务器作为网关，不能及时得到响应时返回此错误代码。

### HTTP 的 GET 和 POST 请求有什么区别？

GET 和 POST 在浏览器上的表现会根据使用场景有各自的优缺点:

- GET 可以直接在浏览器上手动输入请求，在浏览器地址直接请求的 URL 在非匿名模式下会被浏览器记录下来的。这样用户可以通过历史记录来找回之前访问过的页面。反之，POST 不会在浏览器留下痕迹。
- GET 在浏览器地址上的长度是有限制的，POST 没有限制。
- GET 的请求一般可以被浏览器缓存
- 带云压缩的浏览器，比如 Opera mini/Turbo 2, 只有 GET 才能在服务器端被预取

但实际使用时 GET 和 POST 请求所进行的操作取决于服务端是如何解释的。比如一种极端情况就是：不管你是查询、删除、更新还是提交数据也好，所有请求一律使用 POST 来实现都没问题。但这种做法不符合主流的 `RESTful APIs` 设计规范，不建议这样做。

相关讨论参见: [post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？](https://www.zhihu.com/question/31640769?rf=37401322)

### TCP 握手过程

1. 浏览器发送 TCP 分组，这个分组设置了一个特殊的 `SYN` 标记，用来表示这是一条连接请求。
2. 服务器接受到客户端的 `SYN` 连接后, 会选择服务器初始序号 `y`。同时向客户端发送含有连接确认 (`SYN + ACK`)、`Seq=0` (本例中的服务器初始序号)、`ACK=1` (客户端的序号 x + 1) 等信息的 TCP 分组。
3. 客户端收到了服务器的确定字段后，向服务器发送带有 `ACK=1`、`Seq=1`、`Ack=1` (服务器 Ack 信息的拷贝)等字段的 TCP 分组给服务器。
4. 服务器接收到客户端的确认字段后完成三次握手的连接，开始给客户端传输它想要资源

   ![TCP 三次握手](./images/tcp-1.png)

   <details block>
   <summary>点击显示真实案例</summary>

   以下序号 `40`、`44`、`45` 为 TCP 三次握手的具体数据信息。在右侧的 `info` 栏中显示了分组的标志位信息:

   ![TCP 三次握手](./images/tcp-2.png)

   </details>

### 有了解过 HTTP 缓存吗？ <Badge text="TODO" type="warning"/>

主要是指强缓存与协商缓存。

TODO: 待补充区别...

## 运维相关

1. **Q**: 了解过 docker 吗？
2. **Q**: 你们项目的 CI/CD 是怎么搭建的？
3. **Q**: 阿里云的 CDN 资源有缓存，如何强制更新缓存?  
   **A**: 阿里云 CDN 中有一个 Tab 叫**刷新预热**, 在该选项中可以强制刷新缓存。更新缓存的方式有 **URL 刷新**、**目录刷新**以及 **URL 预热**。
4. **Q**: git 除了 `pull`、`push` 外还了解哪些命令？  
   **A**: 可以参考 [Git 速查笔记](../git/README.md) 来回答

## 其他

1. 你哪些项目实现的比较满意？
2. 你碰到最难的一个问题是什么？
3. 是否写过测试用例
4. 是否了解敏捷开发
