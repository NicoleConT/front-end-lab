<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Front end Lab</title>
    <meta name="generator" content="VuePress 1.6.0">
    <link rel="icon" href="/front-end-lab/icons/logo.svg">
    <link rel="manifest" href="/front-end-lab/manifest.json">
    <link rel="apple-touch-icon" href="/front-end-lab/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/front-end-lab/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="Web 开发笔记与解决方案">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    <link rel="preload" href="/front-end-lab/assets/css/0.styles.5f314a78.css" as="style"><link rel="preload" href="/front-end-lab/assets/js/app.e02e37a4.js" as="script"><link rel="preload" href="/front-end-lab/assets/js/2.9a3fe56a.js" as="script"><link rel="preload" href="/front-end-lab/assets/js/22.199b8985.js" as="script"><link rel="preload" href="/front-end-lab/assets/js/4.88b13e9f.js" as="script"><link rel="prefetch" href="/front-end-lab/assets/js/10.8e2bb6c9.js"><link rel="prefetch" href="/front-end-lab/assets/js/11.11086550.js"><link rel="prefetch" href="/front-end-lab/assets/js/12.cdf9df99.js"><link rel="prefetch" href="/front-end-lab/assets/js/13.20e1f2e8.js"><link rel="prefetch" href="/front-end-lab/assets/js/14.3c941d22.js"><link rel="prefetch" href="/front-end-lab/assets/js/15.23ca3dbb.js"><link rel="prefetch" href="/front-end-lab/assets/js/16.6a89357b.js"><link rel="prefetch" href="/front-end-lab/assets/js/17.6305b397.js"><link rel="prefetch" href="/front-end-lab/assets/js/18.6279cfdd.js"><link rel="prefetch" href="/front-end-lab/assets/js/19.05266b45.js"><link rel="prefetch" href="/front-end-lab/assets/js/20.d9871947.js"><link rel="prefetch" href="/front-end-lab/assets/js/21.37d17652.js"><link rel="prefetch" href="/front-end-lab/assets/js/23.d762adf5.js"><link rel="prefetch" href="/front-end-lab/assets/js/24.d8bb8f08.js"><link rel="prefetch" href="/front-end-lab/assets/js/3.b6ecb846.js"><link rel="prefetch" href="/front-end-lab/assets/js/5.f936d390.js"><link rel="prefetch" href="/front-end-lab/assets/js/6.a1ed3d85.js"><link rel="prefetch" href="/front-end-lab/assets/js/7.20255447.js"><link rel="prefetch" href="/front-end-lab/assets/js/8.9f778e62.js"><link rel="prefetch" href="/front-end-lab/assets/js/9.dd04e079.js">
    <link rel="stylesheet" href="/front-end-lab/assets/css/0.styles.5f314a78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-lab/" class="home-link router-link-active"><!----> <span class="site-name">Front end Lab</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-lab/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/front-end-lab/javascript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/front-end-lab/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/front-end-lab/REGEXP/" class="nav-link">
  REGEXP
</a></div><div class="nav-item"><a href="/front-end-lab/topic/2020.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/typescript/" class="nav-link">
  TypeScript
</a></li></ul></li><li class="dropdown-item"><h4>
          笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/operations/" class="nav-link">
  运维笔记
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/mobile/" class="nav-link">
  移动端开发解决方案
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/further/" class="nav-link">
  扩展阅读
</a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Web 展示页
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li></ul></div></div> <a href="https://github.com/anran758/front-end-lab" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-lab/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/front-end-lab/javascript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/front-end-lab/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/front-end-lab/REGEXP/" class="nav-link">
  REGEXP
</a></div><div class="nav-item"><a href="/front-end-lab/topic/2020.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/typescript/" class="nav-link">
  TypeScript
</a></li></ul></li><li class="dropdown-item"><h4>
          笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/operations/" class="nav-link">
  运维笔记
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/mobile/" class="nav-link">
  移动端开发解决方案
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/further/" class="nav-link">
  扩展阅读
</a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Web 展示页
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li></ul></div></div> <a href="https://github.com/anran758/front-end-lab" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-lab/topic/2020.html#html" class="sidebar-link">html</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#把带-css-链接的-link-标签放在-head-标签内-而带-js-链接的-script-标签尽量靠近-body-为什么会有这种提议-如果必须不这样做-如何处理" class="sidebar-link">把带 css 链接的 &lt;link&gt; 标签放在 &lt;head&gt; 标签内，而带 js 链接的 &lt;script&gt; 标签尽量靠近 &lt;/body&gt;, 为什么会有这种提议？如果必须不这样做，如何处理？</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#css" class="sidebar-link">css</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#列举水平垂直居中的实现" class="sidebar-link">列举水平垂直居中的实现</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#计算样式权重" class="sidebar-link">计算样式权重</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#javascript" class="sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#数组去重" class="sidebar-link">数组去重</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#数组多层扁平化" class="sidebar-link">数组多层扁平化</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#深拷贝数组和对象" class="sidebar-link">深拷贝数组和对象</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#数组里面有-10-万个数据-取第-1-个数据与第-10-万个数据的时间相差多少" class="sidebar-link">数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#数组的-map-和-foreach-有什么区别" class="sidebar-link">数组的 map 和 forEach 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#fetch-与-xhr-的区别" class="sidebar-link">Fetch 与 XHR 的区别?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#bind、call、apply-的区别" class="sidebar-link">bind、call、apply 的区别?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#如何检测变量的类型-尽可能多-描述可能出现的问题" class="sidebar-link">如何检测变量的类型(尽可能多，描述可能出现的问题)?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#简述一下原型链" class="sidebar-link">简述一下原型链</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#使用过-es6-吗-你常用的有哪一些" class="sidebar-link">使用过 ES6 吗？你常用的有哪一些？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#简述一下-promise-的特点" class="sidebar-link">简述一下 Promise 的特点</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#promise-怎么做异常处理" class="sidebar-link">Promise 怎么做异常处理?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#promise-串联加载" class="sidebar-link">Promise 串联加载?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#promise-并行加载" class="sidebar-link">Promise 并行加载?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#promise-限流并发" class="sidebar-link">Promise 限流并发?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#async-await" class="sidebar-link">async/await?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#一定要使用-async-await-吗-如果我不做异步处理-可能只是处理简单的关闭弹框不能用-promise-吗" class="sidebar-link">一定要使用 async/await 吗，如果我不做异步处理，可能只是处理简单的关闭弹框不能用 Promise 吗?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#事件循环-event-loop" class="sidebar-link">事件循环 (event-loop)</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#计算题" class="sidebar-link">计算题</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#概念类" class="sidebar-link">概念类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#什么是闭包-列举闭包的应用场景" class="sidebar-link">什么是闭包？列举闭包的应用场景</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#什么是科里化" class="sidebar-link">什么是科里化？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#节流与防抖" class="sidebar-link">节流与防抖</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#说说从浏览器地址栏输入-url-到页面加载完的过程中都发生了什么事情" class="sidebar-link">说说从浏览器地址栏输入 URL 到页面加载完的过程中都发生了什么事情?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#什么是纯函数" class="sidebar-link">什么是纯函数</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#typescript" class="sidebar-link">TypeScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#为什么要引入-typescript-引入的好处是什么" class="sidebar-link">为什么要引入 TypeScript，引入的好处是什么？</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#react" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-是单向数据流还是双向数据流-它还有其他特点吗" class="sidebar-link">React 是单向数据流还是双向数据流？它还有其他特点吗？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-通过什么方式来更新数据" class="sidebar-link">React 通过什么方式来更新数据</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-不能直接修改-state-吗" class="sidebar-link">React 不能直接修改 State 吗？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#setstate-是同步还是异步的" class="sidebar-link">setState 是同步还是异步的？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#函数组件是什么-与类组件有什么区别" class="sidebar-link">函数组件是什么？与类组件有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#受控组件与非受控组件的区别" class="sidebar-link">受控组件与非受控组件的区别</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-生命周期" class="sidebar-link">React 生命周期</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-组件通信" class="sidebar-link">React 组件通信</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-context-怎么使用" class="sidebar-link">React.Context 怎么使用</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-怎么做代码复用" class="sidebar-link">React 怎么做代码复用</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#高阶函数、高阶组件是什么" class="sidebar-link">高阶函数、高阶组件是什么？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#渲染列表为啥要用-key" class="sidebar-link">渲染列表为啥要用 key？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#虚拟-dom-是如何提升性能的" class="sidebar-link">虚拟 dom 是如何提升性能的</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#可以描述一下-react-diffing-算法吗" class="sidebar-link">可以描述一下 React Diffing 算法吗？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#react-性能优化" class="sidebar-link">React 性能优化</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免" class="sidebar-link">父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#异步组件怎么使用" class="sidebar-link">异步组件怎么使用？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#jsx-是如何编译为-js-代码的" class="sidebar-link">JSX 是如何编译为 js 代码的？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#hooks-相比-class-的优点" class="sidebar-link">Hooks 相比 class 的优点</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#hooks-的使用" class="sidebar-link">Hooks 的使用</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#自定义-hook-怎么使用" class="sidebar-link">自定义 Hook 怎么使用</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#hook-使用约束" class="sidebar-link">Hook 使用约束</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#hooks-怎么实现-class-组件的功能" class="sidebar-link">Hooks 怎么实现 class 组件的功能</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#有了解过-portals-吗" class="sidebar-link">有了解过 Portals 吗?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#怎么对组件的参数做类型约束呢" class="sidebar-link">怎么对组件的参数做类型约束呢?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#组件设计原则" class="sidebar-link">组件设计原则</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#redux是什么-它遵循什么原则吗" class="sidebar-link">redux是什么? 它遵循什么原则吗?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#描述-redux-单向数据流" class="sidebar-link">描述 redux 单向数据流</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#vue" class="sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#列举-vue-的生命周期以及它们的应用场景" class="sidebar-link">列举 Vue 的生命周期以及它们的应用场景</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#父组件和子组件生命周期钩子执行顺序是什么" class="sidebar-link">父组件和子组件生命周期钩子执行顺序是什么？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#dom-渲染在-vue-的哪个生命周期就已经完成" class="sidebar-link">DOM 渲染在 Vue 的哪个生命周期就已经完成</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#v-for-遍历模板时为什么要用-key-key-有什么用" class="sidebar-link">v-for 遍历模板时为什么要用 key? key 有什么用？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#v-if-与-v-show-有什么区别-在什么场景下可以应用" class="sidebar-link">v-if 与 v-show 有什么区别? 在什么场景下可以应用</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#vue-组件通信" class="sidebar-link">vue 组件通信</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#vue-的双向绑定原理是什么" class="sidebar-link">vue 的双向绑定原理是什么？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#怎么在组件中实现-v-modal" class="sidebar-link">怎么在组件中实现 v-modal</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#beforedestroy-一般的用途" class="sidebar-link">beforeDestroy 一般的用途</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#vue-router-的-beforeeach-和-aftereach-一般用法-使用场景" class="sidebar-link">vue router 的 beforeEach 和 afterEach 一般用法/使用场景?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#虚拟-dom" class="sidebar-link">虚拟 DOM</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#vdom-diff-特点" class="sidebar-link">vdom diff 特点</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#vdom-diff-算法的事件复杂度" class="sidebar-link">vdom diff 算法的事件复杂度</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#vue-性能优化" class="sidebar-link">vue 性能优化</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#vue-与-react-的区别" class="sidebar-link">Vue 与 React 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-lab/topic/2020.html#webpack" class="sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#module、chunk、bundle-分别是什么" class="sidebar-link">module、chunk、bundle 分别是什么？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#loader-和-plugin-有什么区别-有自己实现过吗" class="sidebar-link">loader 和 plugin 有什么区别？有自己实现过吗？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#除了做基础脚手架外-还用来做过什么" class="sidebar-link">除了做基础脚手架外，还用来做过什么?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#webpack-实现懒加载" class="sidebar-link">webpack 实现懒加载</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#webpack-优化项" class="sidebar-link">webpack 优化项</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#babel-runtime-和-babel-polyfill" class="sidebar-link">babel-runtime 和 babel-polyfill</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#什么是-tree-shaking" class="sidebar-link">什么是 Tree-Shaking</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#rollup-和-webpack-有什么区别" class="sidebar-link">rollup 和 webpack 有什么区别？</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#优化类" class="sidebar-link">优化类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#spa-vue-react-如何优化首页的加载速度-首屏空白是什么问题引起的" class="sidebar-link">SPA（vue/react） 如何优化首页的加载速度？首屏空白是什么问题引起的？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#页面性能优化有哪些方案" class="sidebar-link">页面性能优化有哪些方案？</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#解决方案" class="sidebar-link">解决方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#列举移动端适配方案" class="sidebar-link">列举移动端适配方案</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#怎么处理跨域" class="sidebar-link">怎么处理跨域？</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#http" class="sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#列举-http-状态码以及它们的含义" class="sidebar-link">列举 HTTP 状态码以及它们的含义</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#http-的-get-和-post-请求有什么区别" class="sidebar-link">HTTP 的 GET 和 POST 请求有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#http-握手过程" class="sidebar-link">HTTP 握手过程</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#有了解过-http-缓存吗" class="sidebar-link">有了解过 HTTP 缓存吗？</a></li></ul></li><li><a href="/front-end-lab/topic/2020.html#运维相关" class="sidebar-link">运维相关</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-lab/topic/2020.html#其他" class="sidebar-link">其他</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_2020-面试笔记"><a href="#_2020-面试笔记" class="header-anchor">#</a> 2020 面试笔记</h1> <p>2020 所碰到的面试题，待完善...</p> <ul><li><a href="#html">html</a> <ul><li><a href="#%E6%8A%8A%E5%B8%A6-css-%E9%93%BE%E6%8E%A5%E7%9A%84-link-%E6%A0%87%E7%AD%BE%E6%94%BE%E5%9C%A8-head-%E6%A0%87%E7%AD%BE%E5%86%85%E8%80%8C%E5%B8%A6-js-%E9%93%BE%E6%8E%A5%E7%9A%84-script-%E6%A0%87%E7%AD%BE%E5%B0%BD%E9%87%8F%E9%9D%A0%E8%BF%91-body-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E7%A7%8D%E6%8F%90%E8%AE%AE%E5%A6%82%E6%9E%9C%E5%BF%85%E9%A1%BB%E4%B8%8D%E8%BF%99%E6%A0%B7%E5%81%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">把带 css 链接的 <code>&lt;link&gt;</code> 标签放在 <code>&lt;head&gt;</code> 标签内，而带 js 链接的 <code>&lt;script&gt;</code> 标签尽量靠近 <code>&lt;/body&gt;</code>, 为什么会有这种提议？如果必须不这样做，如何处理？</a></li></ul></li> <li><a href="#css">css</a> <ul><li><a href="#%E5%88%97%E4%B8%BE%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0">列举水平垂直居中的实现</a></li> <li><a href="#%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%E6%9D%83%E9%87%8D">计算样式权重</a></li></ul></li> <li><a href="#javascript">JavaScript</a> <ul><li><a href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">数组去重</a></li> <li><a href="#%E6%95%B0%E7%BB%84%E5%A4%9A%E5%B1%82%E6%89%81%E5%B9%B3%E5%8C%96">数组多层扁平化</a></li> <li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1">深拷贝数组和对象</a></li> <li><a href="#%E6%95%B0%E7%BB%84%E9%87%8C%E9%9D%A2%E6%9C%89-10-%E4%B8%87%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8F%96%E7%AC%AC-1-%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%AC%AC-10-%E4%B8%87%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E7%9B%B8%E5%B7%AE%E5%A4%9A%E5%B0%91">数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？</a></li> <li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84-map-%E5%92%8C-foreach-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">数组的 map 和 forEach 有什么区别？</a></li> <li><a href="#fetch-%E4%B8%8E-xhr-%E7%9A%84%E5%8C%BA%E5%88%AB">Fetch 与 XHR 的区别?</a></li> <li><a href="#bindcallapply-%E7%9A%84%E5%8C%BA%E5%88%AB">bind、call、apply 的区别?</a></li> <li><a href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E6%8F%8F%E8%BF%B0%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98">如何检测变量的类型(尽可能多，描述可能出现的问题)?</a></li> <li><a href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE">简述一下原型链</a></li> <li><a href="#%E4%BD%BF%E7%94%A8%E8%BF%87-es6-%E5%90%97%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B">使用过 ES6 吗？你常用的有哪一些？</a></li> <li><a href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-promise-%E7%9A%84%E7%89%B9%E7%82%B9">简述一下 Promise 的特点</a></li> <li><a href="#promise-%E6%80%8E%E4%B9%88%E5%81%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">Promise 怎么做异常处理?</a></li> <li><a href="#promise-%E4%B8%B2%E8%81%94%E5%8A%A0%E8%BD%BD">Promise 串联加载?</a></li> <li><a href="#promise-%E5%B9%B6%E8%A1%8C%E5%8A%A0%E8%BD%BD">Promise 并行加载?</a></li> <li><a href="#promise-%E9%99%90%E6%B5%81%E5%B9%B6%E5%8F%91">Promise 限流并发?</a></li> <li><a href="#asyncawait">async/await?</a></li> <li><a href="#%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8-asyncawait-%E5%90%97%E5%A6%82%E6%9E%9C%E6%88%91%E4%B8%8D%E5%81%9A%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E5%A4%84%E7%90%86%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E4%B8%8D%E8%83%BD%E7%94%A8-promise-%E5%90%97">一定要使用 async/await 吗，如果我不做异步处理，可能只是处理简单的关闭弹框不能用 Promise 吗?</a></li> <li><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-event-loop">事件循环 (event-loop)</a></li> <li><a href="#%E8%AE%A1%E7%AE%97%E9%A2%98">计算题</a></li></ul></li> <li><a href="#%E6%A6%82%E5%BF%B5%E7%B1%BB">概念类</a> <ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E5%88%97%E4%B8%BE%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">什么是闭包？列举闭包的应用场景</a></li> <li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%91%E9%87%8C%E5%8C%96">什么是科里化？</a></li> <li><a href="#%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96">节流与防抖</a></li> <li><a href="#%E8%AF%B4%E8%AF%B4%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85">说说从浏览器地址栏输入 URL 到页面加载完的过程中都发生了什么事情?</a></li> <li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0">什么是纯函数</a></li></ul></li> <li><a href="#typescript">TypeScript</a> <ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5-typescript%E5%BC%95%E5%85%A5%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">为什么要引入 TypeScript，引入的好处是什么？</a></li></ul></li> <li><a href="#react">React</a> <ul><li><a href="#react-%E6%98%AF%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BF%98%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AE%83%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E7%89%B9%E7%82%B9%E5%90%97">React 是单向数据流还是双向数据流？它还有其他特点吗？</a></li> <li><a href="#react-%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE">React 通过什么方式来更新数据</a></li> <li><a href="#react-%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-state-%E5%90%97">React 不能直接修改 State 吗？</a></li> <li><a href="#setstate-%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84">setState 是同步还是异步的？</a></li> <li><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">函数组件是什么？与类组件有什么区别？</a></li> <li><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB">受控组件与非受控组件的区别</a></li> <li><a href="#react-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">React 生命周期</a></li> <li><a href="#react-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">React 组件通信</a></li> <li><a href="#reactcontext-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8">React.Context 怎么使用</a></li> <li><a href="#react-%E6%80%8E%E4%B9%88%E5%81%9A%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8">React 怎么做代码复用</a></li> <li><a href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88">高阶函数、高阶组件是什么？</a></li> <li><a href="#%E6%B8%B2%E6%9F%93%E5%88%97%E8%A1%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E7%94%A8-key">渲染列表为啥要用 key？</a></li> <li><a href="#%E8%99%9A%E6%8B%9F-dom-%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84">虚拟 dom 是如何提升性能的</a></li> <li><a href="#%E5%8F%AF%E4%BB%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-react-diffing-%E7%AE%97%E6%B3%95%E5%90%97">可以描述一下 React Diffing 算法吗？</a></li> <li><a href="#react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">React 性能优化</a></li> <li><a href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E5%9C%A8%E6%89%A7%E8%A1%8C-render-%E6%97%B6%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84-render-%E4%BA%8B%E4%BB%B6%E5%A6%82%E6%9E%9C%E4%BC%9A%E8%AF%A5%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D">父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？</a></li> <li><a href="#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8">异步组件怎么使用？</a></li> <li><a href="#jsx-%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%BA-js-%E4%BB%A3%E7%A0%81%E7%9A%84">JSX 是如何编译为 js 代码的？</a></li> <li><a href="#hooks-%E7%9B%B8%E6%AF%94-class-%E7%9A%84%E4%BC%98%E7%82%B9">Hooks 相比 class 的优点</a></li> <li><a href="#hooks-%E7%9A%84%E4%BD%BF%E7%94%A8">Hooks 的使用</a></li> <li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-hook-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8">自定义 Hook 怎么使用</a></li> <li><a href="#hook-%E4%BD%BF%E7%94%A8%E7%BA%A6%E6%9D%9F">Hook 使用约束</a></li> <li><a href="#hooks-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-class-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD">Hooks 怎么实现 class 组件的功能</a> <ul><li><a href="#constructor">constructor</a></li> <li><a href="#getderivedstatefromprops">getDerivedStateFromProps</a></li> <li><a href="#shouldcomponentupdate">shouldComponentUpdate</a></li> <li><a href="#hooks-%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">Hooks 没有实现的生命周期钩子</a></li> <li><a href="#%E5%A6%82%E4%BD%95%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0-hook-%E7%BB%84%E4%BB%B6">如何强制更新 Hook 组件?</a></li> <li><a href="#%E7%B1%BB%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84%E5%88%B0-hooks">类实例成员变量如何映射到 Hooks?</a></li> <li><a href="#hook-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%97%A7%E7%9A%84-props-%E5%92%8C-state">Hook 中如何获取旧的 props 和 state</a></li></ul></li> <li><a href="#%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87-portals-%E5%90%97">有了解过 Portals 吗?</a></li> <li><a href="#%E6%80%8E%E4%B9%88%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E5%81%9A%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E5%91%A2">怎么对组件的参数做类型约束呢?</a></li> <li><a href="#%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">组件设计原则</a></li> <li><a href="#redux%E6%98%AF%E4%BB%80%E4%B9%88-%E5%AE%83%E9%81%B5%E5%BE%AA%E4%BB%80%E4%B9%88%E5%8E%9F%E5%88%99%E5%90%97">redux是什么? 它遵循什么原则吗?</a></li> <li><a href="#%E6%8F%8F%E8%BF%B0-redux-%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">描述 redux 单向数据流</a></li></ul></li> <li><a href="#vue">Vue</a> <ul><li><a href="#%E5%88%97%E4%B8%BE-vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">列举 Vue 的生命周期以及它们的应用场景</a></li> <li><a href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88">父组件和子组件生命周期钩子执行顺序是什么？</a></li> <li><a href="#dom-%E6%B8%B2%E6%9F%93%E5%9C%A8-vue-%E7%9A%84%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%B0%B1%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90">DOM 渲染在 Vue 的哪个生命周期就已经完成</a></li> <li><a href="#v-for-%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-key-key-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">v-for 遍历模板时为什么要用 key? key 有什么用？</a></li> <li><a href="#v-if-%E4%B8%8E-v-show-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8F%AF%E4%BB%A5%E5%BA%94%E7%94%A8">v-if 与 v-show 有什么区别? 在什么场景下可以应用</a></li> <li><a href="#vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">vue 组件通信</a></li> <li><a href="#vue-%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">vue 的双向绑定原理是什么？</a></li> <li><a href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AE%9E%E7%8E%B0-v-modal">怎么在组件中实现 v-modal</a></li> <li><a href="#beforedestroy-%E4%B8%80%E8%88%AC%E7%9A%84%E7%94%A8%E9%80%94">beforeDestroy 一般的用途</a></li> <li><a href="#vue-router-%E7%9A%84-beforeeach-%E5%92%8C-aftereach-%E4%B8%80%E8%88%AC%E7%94%A8%E6%B3%95%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">vue router 的 beforeEach 和 afterEach 一般用法/使用场景?</a></li> <li><a href="#%E8%99%9A%E6%8B%9F-dom">虚拟 DOM</a></li> <li><a href="#vdom-diff-%E7%89%B9%E7%82%B9">vdom diff 特点</a></li> <li><a href="#vdom-diff-%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%8D%E6%9D%82%E5%BA%A6">vdom diff 算法的事件复杂度</a></li> <li><a href="#vue-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">vue 性能优化</a></li></ul></li> <li><a href="#vue-%E4%B8%8E-react-%E7%9A%84%E5%8C%BA%E5%88%AB">Vue 与 React 的区别</a></li> <li><a href="#webpack">webpack</a> <ul><li><a href="#modulechunkbundle-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">module、chunk、bundle 分别是什么？</a></li> <li><a href="#loader-%E5%92%8C-plugin-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%9C%89%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E8%BF%87%E5%90%97">loader 和 plugin 有什么区别？有自己实现过吗？</a></li> <li><a href="#%E9%99%A4%E4%BA%86%E5%81%9A%E5%9F%BA%E7%A1%80%E8%84%9A%E6%89%8B%E6%9E%B6%E5%A4%96%E8%BF%98%E7%94%A8%E6%9D%A5%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88">除了做基础脚手架外，还用来做过什么?</a></li> <li><a href="#webpack-%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD">webpack 实现懒加载</a></li> <li><a href="#webpack-%E4%BC%98%E5%8C%96%E9%A1%B9">webpack 优化项</a></li> <li><a href="#babel-runtime-%E5%92%8C-babel-polyfill">babel-runtime 和 babel-polyfill</a></li> <li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-tree-shaking">什么是 Tree-Shaking</a></li> <li><a href="#rollup-%E5%92%8C-webpack-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">rollup 和 webpack 有什么区别？</a></li></ul></li> <li><a href="#%E4%BC%98%E5%8C%96%E7%B1%BB">优化类</a> <ul><li><a href="#spavuereact-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E9%A6%96%E5%B1%8F%E7%A9%BA%E7%99%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84">SPA（vue/react） 如何优化首页的加载速度？首屏空白是什么问题引起的？</a></li> <li><a href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88">页面性能优化有哪些方案？</a></li></ul></li> <li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a> <ul><li><a href="#%E5%88%97%E4%B8%BE%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88">列举移动端适配方案</a></li> <li><a href="#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F">怎么处理跨域？</a></li></ul></li> <li><a href="#http">HTTP</a> <ul><li><a href="#%E5%88%97%E4%B8%BE-http-%E7%8A%B6%E6%80%81%E7%A0%81%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%90%AB%E4%B9%89">列举 HTTP 状态码以及它们的含义</a></li> <li><a href="#http-%E7%9A%84-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">HTTP 的 GET 和 POST 请求有什么区别？</a></li> <li><a href="#http-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">HTTP 握手过程</a></li> <li><a href="#%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87-http-%E7%BC%93%E5%AD%98%E5%90%97">有了解过 HTTP 缓存吗？</a></li></ul></li> <li><a href="#%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3">运维相关</a></li> <li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul> <h2 id="html"><a href="#html" class="header-anchor">#</a> html</h2> <h3 id="把带-css-链接的-link-标签放在-head-标签内-而带-js-链接的-script-标签尽量靠近-body-为什么会有这种提议-如果必须不这样做-如何处理"><a href="#把带-css-链接的-link-标签放在-head-标签内-而带-js-链接的-script-标签尽量靠近-body-为什么会有这种提议-如果必须不这样做-如何处理" class="header-anchor">#</a> 把带 css 链接的 <code>&lt;link&gt;</code> 标签放在 <code>&lt;head&gt;</code> 标签内，而带 js 链接的 <code>&lt;script&gt;</code> 标签尽量靠近 <code>&lt;/body&gt;</code>, 为什么会有这种提议？如果必须不这样做，如何处理？</h3> <p>HTML 解析是自上向下解析的。若在 <code>&lt;head&gt;</code> 中解析到 <code>&lt;link&gt;</code> 标签的话，可以一边加载样式表渲染样式，一边继续向下解析。</p> <p>若解析到 <code>&lt;script&gt;</code> 标签的话，由于 <code>&lt;script&gt;</code> 有可能会修改 DOM 的结构(比如 <code>document.write()</code>)，因此会停止渲染，先将 <code>&lt;script&gt;</code> 加载完毕并执行后，才继续向下解析。在这阻塞的过程中，用户所看到的页面将是一片空白，会影响用户体验。所以早期最佳实践就是将 <code>&lt;script&gt;</code> 放到 <code>&lt;/body&gt;</code> 之前，这样就不会影响页面的渲染了。</p> <p>HTML5 为 <code>&lt;script&gt;</code> 引入了 <code>async</code> 属性，添加该属性后可使脚本请求并行加载，让尽快解析和执行而不阻塞渲染。常见的应用场景就是没有 <code>DOM</code> 依赖关系或是没有跟其他脚本有依赖关系的脚本，如页面统计等。</p> <h2 id="css"><a href="#css" class="header-anchor">#</a> css</h2> <h3 id="列举水平垂直居中的实现"><a href="#列举水平垂直居中的实现" class="header-anchor">#</a> 列举水平垂直居中的实现</h3> <p><a href="/front-end-lab/css/##layout-居中元素">CSS 居中元素实现示例</a></p> <h3 id="计算样式权重"><a href="#计算样式权重" class="header-anchor">#</a> 计算样式权重</h3> <p>已知设备 IPhone6, 写出 div 最后的 color、font-size 值:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token selector">div</span> <span class="token punctuation">{</span> <span class="token property">font-size</span><span class="token punctuation">:</span> 1rem<span class="token punctuation">;</span> <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token selector">.class1</span> <span class="token punctuation">{</span> <span class="token property">font-size</span><span class="token punctuation">:</span> .32rem<span class="token punctuation">;</span> <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token selector">#id1</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token selector">#id1 div</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> #666<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token selector">.class1 div</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> #999<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token selector">.class1 .class2 div</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> #aaa<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>class1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>id1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>class2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>文字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>答:</strong> 从 DOM 的结构来看共有三层，各层实际被应用的样式为:</p> <ul><li>第一层: <code>font-size: .32rem</code>, <code>color: red</code></li> <li>第二层: <code>font-size: 1rem</code>, <code>color: #333</code></li> <li>第三层(含文字那层): <code>font-size: 1rem</code>, <code>color: #666</code></li></ul> <p>CSS 选择器优先级:</p> <table><thead><tr><th>优先级</th> <th>权重</th> <th>类型</th></tr></thead> <tbody><tr><td>0 级</td> <td>0</td> <td>通配符(<code>*</code>)、选择符(<code>+</code>、<code>&gt;</code>、<code>~</code>、<code>||</code>、空格等)、逻辑组合伪类(<code>:not</code>、<code>:is()</code>、<code>:where</code>)</td></tr> <tr><td>1 级</td> <td>1</td> <td>标签选择器，如 <code>body {...}</code> 等</td></tr> <tr><td>2 级</td> <td>10</td> <td>类选择器(<code>.list {...}</code>)、属性选择器(<code>body] {...}</code>)、伪类(<code>:hover</code>)</td></tr> <tr><td>3 级</td> <td>100</td> <td>ID选择器(<code>#title {...}</code>)</td></tr> <tr><td>4 级</td> <td>内联级</td> <td><code>style</code> 属性内联: <code>&lt;span style=&quot; color: red;&quot; /&gt;</code></td></tr> <tr><td>5 级</td> <td>顶级</td> <td>添加 <code>!important</code> 规则： <code>.title { color: red !important; }</code></td></tr></tbody></table> <p>样式覆盖规则:</p> <ul><li>相同权重的样式，应用最后声明的样式</li> <li>多个选择器则叠加权重，如: <code>.list &gt; .item {...}</code> 的权重为 <code>10 + 0 + 10 = 20</code>。</li> <li><code>style</code> 内联样式默认覆盖外部样式表的样式。除非内联样式设置了普通样式，而外部样式表的样式使用了 <code>!important</code> 规则的情况就无法覆盖。但也可以在 <code>style</code> 设置的样式属性中加上 <code>!important</code> 规则，叠加后权重就更高了(一般不推荐使用 <code>!important</code>)</li></ul> <h2 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h2> <h3 id="数组去重"><a href="#数组去重" class="header-anchor">#</a> 数组去重</h3> <ol><li><p>利用 <code>Set</code> 结构不可重复的特性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> info <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'anran758'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>info<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>info<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 通过扩展运算符将 Set 转为 Array</span>
<span class="token keyword">var</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 或者使用 Array.from 转为 Array</span>
<span class="token keyword">var</span> newArr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>优点: 语法简洁
缺点: Set 添加新值时是通过 <a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero" target="_blank" rel="noopener noreferrer">SameValueZero<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 算法进行比对的, 因此不能做深比较去重</p></blockquote></li> <li><p>使用 <code>indexOf</code> 判断是否具有相同的项</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> info <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;anran758&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> info<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> info<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> <span class="token operator">!</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> item <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>newArr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> newArr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> newArr <span class="token operator">=</span> <span class="token function">uniq</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>优点: 兼容低版本 IE
缺点: 没有实现深比较去重</p></blockquote></li> <li><p>引入 <a href="https://www.lodashjs.com/docs/lodash.uniq" target="_blank" rel="noopener noreferrer">loadsh<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 工具库来处理:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

_<span class="token punctuation">.</span><span class="token function">uniq</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>还可以使用 <a href="https://www.lodashjs.com/docs/lodash.uniqWith" target="_blank" rel="noopener noreferrer">uniqWith<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 搭配 <a href="https://www.lodashjs.com/docs/lodash.isEqual" target="_blank" rel="noopener noreferrer">isEqual<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 实现深比较去重的效果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> objects <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span> <span class="token string">'x'</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token string">'x'</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token string">'x'</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

_<span class="token punctuation">.</span><span class="token function">uniqWith</span><span class="token punctuation">(</span>objects<span class="token punctuation">,</span> _<span class="token punctuation">.</span>isEqual<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]</span>
</code></pre></div><blockquote><p>优点: 语法简洁，使用方便，能满足所有去重需求
缺点: 需要额外引入第三方库</p></blockquote></li></ol> <h3 id="数组多层扁平化"><a href="#数组多层扁平化" class="header-anchor">#</a> 数组多层扁平化</h3> <ol><li><p><code>Array.flat</code>: 数组的 <code>flat</code> 方法接受一个数值参数，该参数是指定需要扁平化的层数。若想将数组子项中所有数组进行扁平化，可以传入 <code>Infinity</code>。</p> <p>只扁平化第 1 层:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [0, 1, [2], [[3]], [], 4]</span>
</code></pre></div><p>全部扁平化:</p> <div class="language-js extra-class"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [0, 1, 2, 3, 4]</span>
</code></pre></div></li> <li><p>通过递归的方式处理:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">flatDeep</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> depth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> d <span class="token operator">=</span> depth <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> depth <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> d <span class="token operator">&gt;</span> <span class="token number">0</span>
    <span class="token operator">?</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
      acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
        <span class="token operator">?</span> <span class="token function">flatDeep</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> d <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> val<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">flatDeep</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [0, 1, [2], [[3]], [], 4]</span>

<span class="token function">flatDeep</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [0, 1, 2, 3, 4]</span>
</code></pre></div><p>递归实现有很多思路，<code>reduce</code> 循环合并是一种，<code>for</code> 循环也是一种。它们只是实现细节不同，但递归思想是相通的。</p></li></ol> <h3 id="深拷贝数组和对象"><a href="#深拷贝数组和对象" class="header-anchor">#</a> 深拷贝数组和对象</h3> <ol><li><p>可以先通过 <code>JSON.stringify</code> 将数据转为 JSON 字符串，再通过 <code>JSON.parse</code> 对 JSON 字符串进行解析，可以得到全新的数组/对象。</p> <p>使用该方法进行深拷贝并不算完美，<code>JSON.stringify</code> 只能序列化对象的可枚举属性，如果对象是通过构造函数生成的，那么会丢失 <code>constructor</code>。也不能对有循环引用的对象进行深拷贝。<br>
除此之外，<code>Date</code> 对象会被序列化为字符串。正则表达式、<code>Error</code> 对象会被序列化为空对象。若属性中存在 <code>undefined</code> 则该属性会被丢弃。<code>NaN</code>、<code>Infinity</code> 等信息会被转为 <code>null</code>。<br>
由此可见，如果被拷贝的参数中没有 <code>Date</code>、正则、函数或对象循环引用的问题，可以考虑使用该方法。</p></li> <li><p>可以自己定义递归函数，参数是传入数组或对象。再遍历形参的属性或下标，如果遍历到的类型也是引用类型那就进行浅拷贝，再进行递归，直至全部属性都遍历完毕。</p></li> <li><p>通过第三方类库实现，如 <code>lodash</code> 的 <code>deepClone</code> 就可以实现深拷贝。</p></li></ol> <h3 id="数组里面有-10-万个数据-取第-1-个数据与第-10-万个数据的时间相差多少"><a href="#数组里面有-10-万个数据-取第-1-个数据与第-10-万个数据的时间相差多少" class="header-anchor">#</a> 数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？</h3> <p><strong>A:</strong> 取元素的复杂度为 <code>O(1)</code>, 消耗时间几乎一致，差异可以忽略不计。</p> <h3 id="数组的-map-和-foreach-有什么区别"><a href="#数组的-map-和-foreach-有什么区别" class="header-anchor">#</a> 数组的 map 和 forEach 有什么区别？</h3> <p><code>map</code> 将每一个元素传入函数调用后，会将函数的返回值存入新数组中，因此可以对数组做链式处理。而 <code>forEach</code> 只是将元素传入给函数调用，不会讲返回值存入新数组中。</p> <p>可以参考这个回答: <a href="https://www.zhihu.com/question/278332594/answer/886056097" target="_blank" rel="noopener noreferrer">js es6 中如何比较深刻的理解 map、for、for of？<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="fetch-与-xhr-的区别"><a href="#fetch-与-xhr-的区别" class="header-anchor">#</a> Fetch 与 XHR 的区别?</h3> <ul><li><code>Fetch</code> 是基于 <code>Promise</code> 实现的, 相比 <code>XHR(XMLHttpRequest)</code> 的语法更加简洁。</li> <li><code>Fetch</code> 发送请求时默认不带 <code>cookie</code> 的, 需要设置 <code>credentials</code> 的配置项</li> <li>当接收到一个代表错误的 <code>HTTP</code> 状态码时, 从 <code>fetch()</code> 返回的 <code>Promise</code> 不会被标记为 <code>reject</code>, 即使响应的 <code>HTTP</code> 状态码是 <code>404</code> 或 <code>500</code>。仅当网络故障时或请求被阻止时, 才会标记为 <code>reject</code>。</li> <li><code>Fetch</code> 不支持超时控制与检测请求进度</li></ul> <h3 id="bind、call、apply-的区别"><a href="#bind、call、apply-的区别" class="header-anchor">#</a> bind、call、apply 的区别?</h3> <p>调用 bind 方法后返回一个新函数，新函数的 this 将被指向调用 bind 方法时的第一个参数。而其余参数将作为新函数的参数，供调用时使用</p> <p>call 与 apply 第一个参数也是指定的 this 值，其余的不同是接受参数的不同。call 接受<strong>参数列表</strong>，apply 接受的是<strong>参数数组</strong>。两者相比，call 的性能会更好。</p> <h3 id="如何检测变量的类型-尽可能多-描述可能出现的问题"><a href="#如何检测变量的类型-尽可能多-描述可能出现的问题" class="header-anchor">#</a> 如何检测变量的类型(尽可能多，描述可能出现的问题)?</h3> <p>主要使用 <code>typeof</code>、<code>instantof</code>、<code>Object.prototype.toString.call</code>。还可以使用 <code>Array.isArray</code> 方法判断是否是数组，<code>Number.isNaN</code> 是否是 <code>NaN</code> 等。</p> <p><code>typeof</code> 可以用于 <code>String</code>、<code>Number</code>、<code>Symbol</code>、<code>Boolean</code>、<code>undefined</code> 等类型，但用于 <code>null</code>、<code>Array</code> 类型的话会展示为 <code>object</code> 类型。</p> <p><code>instanceof</code> 则是通过原型链的方式来判断对象类型。但它的局限性在于只要被操作的变量原型有上有该类型的值。它主要缺点是不能检测 <code>number</code>, <code>boolean</code>, <code>string</code> 字面量的类型。</p> <p><code>Object.prototype.toString.call</code> 可以精准的判断类型的值，主要的问题是写法繁琐，可以基于此函数做一层封装:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getBaseType</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> typeStr <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> typeStr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="简述一下原型链"><a href="#简述一下原型链" class="header-anchor">#</a> 简述一下原型链</h3> <p>TODO: 待补充...</p> <h3 id="使用过-es6-吗-你常用的有哪一些"><a href="#使用过-es6-吗-你常用的有哪一些" class="header-anchor">#</a> 使用过 ES6 吗？你常用的有哪一些？</h3> <ul><li>let/const 自身特性与块级作用域</li> <li>模板字符串</li> <li>解构赋值</li> <li>函数默认参数</li> <li>箭头函数</li> <li>Promise</li> <li>async/await</li></ul> <h3 id="简述一下-promise-的特点"><a href="#简述一下-promise-的特点" class="header-anchor">#</a> 简述一下 Promise 的特点</h3> <ul><li>主要用于异步计算.</li> <li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。</li> <li>可以在对象之间传递和操作 Promise，帮助我们处理队列。</li> <li>链式写法更简洁，可以避免回调地狱</li></ul> <h3 id="promise-怎么做异常处理"><a href="#promise-怎么做异常处理" class="header-anchor">#</a> Promise 怎么做异常处理?</h3> <ol><li>Promise 最末尾添加 catch() 是统一 catch 错误</li> <li>Promise.then 的第二个参数捕获错误</li></ol> <p>衍生问题:</p> <p><strong>Q: <code>try...catch</code> 可以捕获 Promise.reject 错误吗，具体说说原因？</strong></p> <p>A: <code>try...catch</code> 是同步代码，而 <code>Promise</code>、<code>setTimeout</code> 等语句是异步代码，因此当异步代码发生错误时，<code>try...catch</code> 代码块已经执行完毕了，因此被抛出错误。</p> <h3 id="promise-串联加载"><a href="#promise-串联加载" class="header-anchor">#</a> Promise 串联加载?</h3> <ol><li>通过 async await ，等异步函数执行完毕取出 Promise 中的值</li> <li>通过 then 链式传递串联</li></ol> <h3 id="promise-并行加载"><a href="#promise-并行加载" class="header-anchor">#</a> Promise 并行加载?</h3> <p>可以使用 <code>Promise.all</code>。</p> <p><code>Promise.all</code> 接受一个数组，数组内可以是对象、数组或者字符串等基本类型，也可以是 <code>Promise</code> 类型。</p> <p>若数组中有 <code>Promise</code> 类型，当所有 <code>Promise</code> 的状态都变为成功后，就会进入 <code>Promise.all</code> 的 then 方法中，若有一项 <code>Promise</code> 状态变为 <code>reject</code>，则 <code>Promise.all</code> 的状态变为 <code>reject</code>。</p> <h3 id="promise-限流并发"><a href="#promise-限流并发" class="header-anchor">#</a> Promise 限流并发?</h3> <p>TODO: 待补充...</p> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await?</h3> <ul><li>async/await 是最直接的同步写法，在也没有回调函数</li> <li>async/await 使用了 Promise，并没有和 Promise 产生冲突</li> <li>但还是改变不了 js 单线程、异步的本质</li></ul> <h3 id="一定要使用-async-await-吗-如果我不做异步处理-可能只是处理简单的关闭弹框不能用-promise-吗"><a href="#一定要使用-async-await-吗-如果我不做异步处理-可能只是处理简单的关闭弹框不能用-promise-吗" class="header-anchor">#</a> 一定要使用 async/await 吗，如果我不做异步处理，可能只是处理简单的关闭弹框不能用 Promise 吗?</h3> <p>这个问题没有标准答案，这个提问的目的是主要看你自己的见解或看法。面试官倾向非异步请求可以通过 Promise 处理，异步请求可以使用 async/await 处理，将使用用途区分开。</p> <h3 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="header-anchor">#</a> 事件循环 (event-loop)</h3> <ol><li><p>什么是单线程？和异步有什么关系？</p> <blockquote><p>TODO: 待补充...</p></blockquote></li> <li><p>什么是事件循环</p> <p>js 是一个单线程非阻塞的语言，单线程意味着所有任务都要排队。但有一些任务耗时很长，js 引擎不想因为这些耗时长的任务而阻塞后面任务的处理。因此将这些任务分为<strong>同步任务</strong>与<strong>异步任务</strong>。</p> <p>事件循环中的任务又区分宏任务(Microtasks)与微任务(task)。两种任务各有一个任务队列。首先会执行微任务，然后再执行宏任务。</p> <blockquote><p>TODO: 待补充...</p></blockquote></li> <li><p><code>setTimeout</code> 是否有误差？若有，产生误差的原因是什么？</p> <p>零延迟并不意味着回调会立即执行，其等待的时间取决于队列里待处理的消息数量。</p></li> <li><p>以下程序依次输出的信息是:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是开始'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是来自第一个回调的消息'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是一条消息'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">cb1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是来自第二个回调的消息'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是结束'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// &quot;这是开始&quot;</span>
<span class="token comment">// &quot;这是一条消息&quot;</span>
<span class="token comment">// &quot;这是结束&quot;</span>
<span class="token comment">// &quot;这是来自第一个回调的消息&quot;</span>
<span class="token comment">// &quot;这是来自第二个回调的消息&quot;</span>
</code></pre></div></li></ol> <h3 id="计算题"><a href="#计算题" class="header-anchor">#</a> 计算题</h3> <ol><li><p>按顺序写出程序的输出结果:</p> <blockquote><p>考察 this 问题</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> length <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  length<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
  <span class="token function-variable function">callApi</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

obj<span class="token punctuation">.</span><span class="token function">callApi</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><p>该段代码依次输出 <code>10</code>、<code>2</code>。<strong>函数的调用方式决定了 <code>this</code> 的值</strong>。第二个函数调用是通过 <code>arguments</code> 调用，那么 <code>this</code> 自然指向 <code>arguments</code>，那 <code>arguments</code> 的实参有 <code>fn</code> 跟 <code>3</code> 两个参数，因此输出 <code>2</code>。</p></li> <li><p>列出下面代码的不足及优化方案</p> <blockquote><p>考察事件代理与 nodeList</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'click'</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>改造下面的代码，使之输出 0 ~ 9，写出你能想到的所有解法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li><p><code>var</code> 改为 <code>let</code></p></li> <li><p>循环体内的代码改为立即执行函数，利用闭包来修复</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>将循环体内的代码封装到新函数中，在循环体中调用该函数并传入 <code>i</code></p></li> <li><p>将 <code>i</code> 作为 <code>setTimeout</code> 内部函数的额外参数传入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div></li></ol></li> <li><p>请写出下面代码的运行结果</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;async1 start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;async1 end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;async2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">reslove</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reslove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>依次输出的是:</p> <ul><li>script start</li> <li>async1 start</li> <li>async2</li> <li>promise1</li> <li>script end</li> <li>async1 end</li> <li>promise2</li> <li>setTimeout</li></ul></li> <li><p>下面的代码会进入 <code>.catch</code> 吗？解释一下你的答案。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Whoops!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;catched!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>A: 不会进入 <code>.catch</code>, 因为 <code>try...catch</code> 无法捕获异步代码的错误。</p></li></ol> <h2 id="概念类"><a href="#概念类" class="header-anchor">#</a> 概念类</h2> <h3 id="什么是闭包-列举闭包的应用场景"><a href="#什么是闭包-列举闭包的应用场景" class="header-anchor">#</a> 什么是闭包？列举闭包的应用场景</h3> <p>闭包主要指一个函数及其周围封闭词法环境中的引用构成闭包，这也是一种语言特性。从实践的角度来看，满足以下两个条件的才能称为闭包:</p> <ol><li>创建该函数的上下文被销毁了，但该函数仍然存在</li> <li>函数内有引用外部变量</li></ol> <p>常见的应用场景是，在一个函数的局部作用域中创建一个内部函数，再将这个内部函数返回出去。
内部函数总是可以访问创建它的上下文，也就是外部函数中声明的参数和变量，即使创建内部函数的上下文已经销毁。例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> prefix <span class="token operator">=</span> <span class="token string">&quot;dvelopment_&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prefix <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> showName <span class="token operator">=</span> <span class="token function">createName</span><span class="token punctuation">(</span><span class="token string">'anran758'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>调用 <code>createName</code> 后返回了一个函数并赋值给了 <code>showName</code> 变量，同时 <code>createName</code> 的上下文被销毁。
此时再调用 <code>showName</code> 函数时，尽管 <code>createName</code> 的上下文已经被销毁了，但 <code>showName</code> 中还能获取 <code>createName</code> 的内部变量与形参，这就是闭包的一种应用。</p> <h3 id="什么是科里化"><a href="#什么是科里化" class="header-anchor">#</a> 什么是科里化？</h3> <p>柯里化是一种将<strong>使用多个参数的函数</strong>转换成一系列<strong>使用一个参数的函数</strong>的技术，本质上也是利用了闭包的特性。科里化可以做到<strong>参数复用</strong>和<strong>延迟执行</strong>的效果。</p> <p>例如，若传入了给定函数的所定义的参数数量后执行函数:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> fn<span class="token punctuation">.</span>length <span class="token operator">!==</span> rest<span class="token punctuation">.</span>length
    <span class="token operator">?</span> <span class="token keyword">function</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> rest<span class="token punctuation">.</span>length <span class="token operator">+</span> args<span class="token punctuation">.</span>length <span class="token operator">!==</span> fn<span class="token punctuation">.</span>length
        <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token operator">:</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">curry</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 6</span>
</code></pre></div><h3 id="节流与防抖"><a href="#节流与防抖" class="header-anchor">#</a> 节流与防抖</h3> <ul><li>函数节流(Throttle)是：在固定的时间内触发事件，每隔 n 秒只触发一次 (例子: 移动端下拉页面)</li> <li>函数防抖是：当你频繁触发后，n 秒内只执行一次 (例子: window.resize 触发事件，通过防抖只更新最后一次事件)</li></ul> <h3 id="说说从浏览器地址栏输入-url-到页面加载完的过程中都发生了什么事情"><a href="#说说从浏览器地址栏输入-url-到页面加载完的过程中都发生了什么事情" class="header-anchor">#</a> 说说从浏览器地址栏输入 URL 到页面加载完的过程中都发生了什么事情?</h3> <p><a href="https://zhuanlan.zhihu.com/p/95904514" target="_blank" rel="noopener noreferrer">从浏览器地址栏输入 URL 到页面渲染之间都经历了什么<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="什么是纯函数"><a href="#什么是纯函数" class="header-anchor">#</a> 什么是纯函数</h3> <p>纯函数由三大原则构成：</p> <ol><li>给定相同输入，它总是返回相同的输出</li> <li>过程没有副作用(side effect)</li> <li>没有额外的状态依赖</li></ol> <h2 id="typescript"><a href="#typescript" class="header-anchor">#</a> TypeScript</h2> <h3 id="为什么要引入-typescript-引入的好处是什么"><a href="#为什么要引入-typescript-引入的好处是什么" class="header-anchor">#</a> 为什么要引入 TypeScript，引入的好处是什么？</h3> <p>TODO: 待补充...</p> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <h3 id="react-是单向数据流还是双向数据流-它还有其他特点吗"><a href="#react-是单向数据流还是双向数据流-它还有其他特点吗" class="header-anchor">#</a> React 是单向数据流还是双向数据流？它还有其他特点吗？</h3> <ul><li>React 是单向数据流，数据是从上向下流</li> <li>声明式编写 UI</li> <li>组件化开发</li></ul> <h3 id="react-通过什么方式来更新数据"><a href="#react-通过什么方式来更新数据" class="header-anchor">#</a> React 通过什么方式来更新数据</h3> <p>React 是通过 <code>setState</code> 来更新数据的。调用多个 <code>setState</code> 不会立即更新数据，而是批量延迟更新后再将数据合并。</p> <p>除了 <code>setState</code> 外还可以使用 <code>forceUpdate</code> 跳过当前组件的 <code>shouldComponentUpdate</code> 对比，强制触发组件渲染(避免使用该方式)。</p> <h3 id="react-不能直接修改-state-吗"><a href="#react-不能直接修改-state-吗" class="header-anchor">#</a> React 不能直接修改 State 吗？</h3> <ol><li>直接修改 state 不会触发组件的渲染。</li> <li>若直接修改 state 引用的值，在实际使用时会导致错误的值出现</li> <li>修改后的 state 可能会被后续调用的 <code>setState</code> 覆盖</li></ol> <h3 id="setstate-是同步还是异步的"><a href="#setstate-是同步还是异步的" class="header-anchor">#</a> setState 是同步还是异步的？</h3> <p>出于性能的考虑，可能会把多个 <code>setState</code> 合并成一个调用。</p> <p>在 React 控制的生命周期、React 封装的事件处理器中直接使用是异步的(命中 <code>batchUpdate</code> 机制，<code>isBatchingUpdate</code> 的标志位为 <code>true</code>)。比如 React中注册的 <code>onClick</code> 事件或是 <code>componentDidMount</code> 中直接使用都是异步的。</p> <p>可以给 <code>setState</code> 第二个参数传递一个函数，该函数是<strong>数据更新后会触发的回调函数</strong>。在该函数中可以拿到更新后最新的值。</p> <p>在 React 控制外中使用 <code>setState</code> 是同步的，比如在  <code>setTimeout</code>, 或者是原生的事件监听器中使用都是同步的。</p> <h3 id="函数组件是什么-与类组件有什么区别"><a href="#函数组件是什么-与类组件有什么区别" class="header-anchor">#</a> 函数组件是什么？与类组件有什么区别？</h3> <p>函数组件本质上是一个纯函数，它接受 props 属性，最后返回 JSX。</p> <p>与类组件的差别在于: 它没有实例、不能通过 <code>extends</code> 继承于其他方法、也没有生命周期和 <code>state</code>(但可以引入 <code>Hooks</code> 来处理没有生命周期和 <code>state</code> 的问题)。</p> <h3 id="受控组件与非受控组件的区别"><a href="#受控组件与非受控组件的区别" class="header-anchor">#</a> 受控组件与非受控组件的区别</h3> <p>受控组件主要是指表单的值受到 <code>state</code> 的控制，它需要自行监听 <code>onChange</code> 事件来更新 <code>state</code>。</p> <p>由于受控组件每次都要编写事件处理器才能更新 <code>state</code> 数据、可能会有点麻烦，React 提供另一种代替方案是<strong>非受控组件</strong>。</p> <p>非受控组件将<strong>真实数据储存在 DOM 节点</strong>中,它可以为表单项设置默认值，不需要手动更新数据。当需要用到表单数据时再通过 <code>ref</code> 从 DOM 节点中取出数据即可。</p> <p><strong>注意: 多数情况下React 推荐编写受控组件。</strong></p> <p>扩展资料: <a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" target="_blank" rel="noopener noreferrer">受控和非受控制使用场景的选择<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react-生命周期"><a href="#react-生命周期" class="header-anchor">#</a> React 生命周期</h3> <p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">React 生命周期图<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>TODO: 待补充*(父子)组件生命周期*...</p> <h3 id="react-组件通信"><a href="#react-组件通信" class="header-anchor">#</a> React 组件通信</h3> <ul><li>父组件通过 props 给子组件传参，子组件通过触发父组件提供的回调函数来给父组件传递数据</li> <li>React.Context</li> <li>自定义事件</li> <li>redux/mobx 之类的状态管理器</li></ul> <h3 id="react-context-怎么使用"><a href="#react-context-怎么使用" class="header-anchor">#</a> React.Context 怎么使用</h3> <p><code>Context</code> 可以共享对于组件树而言是全局的数据，比如全局主题、首选语言等。使用方式如下：</p> <ol><li><p><code>React.createContext</code> 函数用于生成 <code>Context</code> 对象。可以在创建时给 <code>Context</code> 设置默认值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>Context</code> 对象中有一个 <code>Provider(提供者)</code> 组件，<code>Provider</code> 组件接受一个 <code>value</code> 属性用以将数据传递给消费组件。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeContext.Provider</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dark<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>page</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeContext.Provider</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>获取 <code>Context</code> 提供的值可以通过 <code>contextType</code> 或者 <code>Consumer(消费者)</code> 组件中获取。<code>contextType</code> 只能用于类组件，并且只能挂载一个 <code>Context</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
    <span class="token comment">/* 在组件挂载完成后，使用 MyContext 的值执行一些有副作用的操作 */</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
    <span class="token comment">/* 基于 MyContext 的值进行渲染 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
MyClass<span class="token punctuation">.</span>contextType <span class="token operator">=</span> MyContext<span class="token punctuation">;</span>
</code></pre></div><p>若想给组件挂载多个 <code>Context</code>, 或者在函数组件内使用 <code>Context</code> 可以使用 <code>Consumer</code> 组件:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeContext.Consumer</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token punctuation">{</span><span class="token parameter">theme</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">UserContext.Consumer</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span><span class="token parameter">user</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ProfilePage</span></span> <span class="token attr-name">user</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span></span> <span class="token attr-name">theme</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>theme<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
      <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">UserContext.Consumer</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeContext.Consumer</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol> <p><code>Context</code> 通常适用于传递较为简单的数据信息，若数据太过复杂，还是需要引入状态管理(redux/mbox)。</p> <h3 id="react-怎么做代码复用"><a href="#react-怎么做代码复用" class="header-anchor">#</a> React 怎么做代码复用</h3> <ul><li><a href="https://react.html.cn/docs/render-props.html" target="_blank" rel="noopener noreferrer">Render Props<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>高阶组件 (HOC)</li> <li>自定义 Hooks</li> <li>Mixins (已被 React 废弃的方案)</li></ul> <p><code>Render props</code> 是一种在 React 组件之间共享代码的简单技术。具体的行为是:</p> <ol><li>子组件接收一个用于渲染指定视图的 <code>prop</code> 属性，该属性的类型是函数。</li> <li>父组件在组件内部定义该函数后，将函数的引入传给子组件</li> <li>子组件将组件内部 <code>state</code> 作为实参传给从外面传来的函数，并将函数的返回结果渲染在指定的视图区域。</li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 组件使用</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Mouse</span></span> <span class="token attr-name">render</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">x: </span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token plain-text">, y: </span><span class="token punctuation">{</span>y<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token comment">// 组件内部大致实现</span>
<span class="token keyword">class</span> <span class="token class-name">Mouse</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">头部信息</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">底部信息</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>准确来说 <code>Render props</code> 是一个用于告知组件需要渲染什么内容的函数属性。<code>props</code> 的命名可以由自己定义，比如用于在内容区域渲染的 prop 名可以叫 <code>render</code>，同时还可以再接收一个 <code>renderHead</code> 的 prop 用于渲染头部的信息。</p> <h3 id="高阶函数、高阶组件是什么"><a href="#高阶函数、高阶组件是什么" class="header-anchor">#</a> 高阶函数、高阶组件是什么？</h3> <p><strong>高阶函数</strong>就是<strong>接收其它函数作为参数</strong>的函数就称之为高阶函数，像数组的 <code>map</code> 、<code>sort</code>、<code>filter</code> 都是高阶函数。</p> <p><strong>高阶组件(Higher-order component, HOC)</strong> 是 React 用于复用组件逻辑的一种高级技巧。它具体的行为是：</p> <p>函数<strong>接收一个组件作为参数</strong>，在函数体内<strong>定义一个新组件</strong>，新组件内<strong>编写可复用的逻辑</strong>并应用到参数组件中。最后再将<strong>新组件作为函数的返回值</strong> return 出去。
<code>redux</code> 中的 <code>connect</code> 函数就是一个高阶组件。</p> <h3 id="渲染列表为啥要用-key"><a href="#渲染列表为啥要用-key" class="header-anchor">#</a> 渲染列表为啥要用 key？</h3> <p>渲染列表时，如果不给列表子项传 <code>key</code> 的话，React 将默认使用 <code>index</code> 作为 <code>key</code>，同时会在控制台发出警告。</p> <p><code>key</code> 在兄弟节点之间必须唯一，要避免使用数组下标 <code>index</code> 作为 <code>key</code>。因为使用数组下标作为 `key 时，若数组的顺序发生了改变，将会影响 Diffing 算法的效率。</p> <p>若列表的节点是组件的话，还可能会影响组件的 <code>state</code> 数据。因为组件实例是基于 <code>key</code> 来决定是否更新与复用。当顺序发生了变化，则 <code>key</code> 也会相应得被修改，从而导致子组件间的数据错乱。</p> <p>React 使用的 Diffing 算法是通过 <code>tag</code> 和 <code>key</code> 判断是否是同一个元素(<code>sameNode</code>)。使用唯一的 <code>key</code> 有助于 React 识别哪些元素发生改变，如节点添加或删除。这样有助于减少渲染次数，从而优化性能。</p> <p>如果数组中的数据没有唯一的 <code>key</code>，可以引入 <a href="https://www.npmjs.com/package/shortid" target="_blank" rel="noopener noreferrer">shortid<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 预先给数组中每项数据生成唯一的 <code>id</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> shortid <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'shortid'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">addId</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>data<span class="token punctuation">,</span>
    id<span class="token operator">:</span> shortid<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> newList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>addId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>若确定没有列表的顺序不会发生变化同时没有其他唯一的 <code>key</code> 来标识列表项时才能使用数组的下标。</p> <h3 id="虚拟-dom-是如何提升性能的"><a href="#虚拟-dom-是如何提升性能的" class="header-anchor">#</a> 虚拟 dom 是如何提升性能的</h3> <p>当组件触发更新时，虚拟 DOM 通过比对新旧 <code>state</code> 和 <code>props</code> 的变化以决定是否渲染 DOM 节点，从而减少渲染提升性能。因为修改真实 DOM 所耗费的性能远比操作 JavaScript 多几倍，因此使用虚拟 DOM 在渲染性能上会高效的多。</p> <h3 id="可以描述一下-react-diffing-算法吗"><a href="#可以描述一下-react-diffing-算法吗" class="header-anchor">#</a> 可以描述一下 React Diffing 算法吗？</h3> <p>Diffing 算法(Diffing Algorithm) 会先比较两个根元素的变化:</p> <ol><li>当<strong>节点类型变化</strong>时，将会卸载原有的树而建立新树。如父节点 <code>&lt;div&gt;</code> 标签被修改为 <code>&lt;section&gt;</code> 标签，则它们自身及 <code>children</code> 下的节点都会被重新渲染。</li> <li>当 <strong>DOM 节点类型相同</strong>时，保留相同的 DOM 节点，仅更新发生改变的属性。</li> <li>当<strong>组件类型相同时</strong>，组件更新时组件实例保持不变，React 将更新组件实例的 props, 并调用生命周期 <code>componentWillReceiveProps()</code> 和 <code>componentwillupdate()</code>，最后再调用 <code>render</code>。若 <code>render</code> 中还有子组件，将递归触发 Diff。</li> <li>当<strong>列表节点发生变化，列表项没有设置 key 时</strong>, 那么 Diffing 算法会逐个对比节点的变化。如果是尾部新增节点，那 Diff 算法会 Diff 到列表末尾，仅新增元素即可，不会有其他的性能损耗。若新增的数据不在数组的尾部而是在中间，那么 Diffing 算法比较到中间时判断出节点发生变化，将会丢弃后面所有节点并重新渲染。</li> <li>当<strong>列表节点发生变化，列表项有设置 key 时</strong>, React 可以通过 <code>key</code> 来匹配新旧节点间的对应关系，可以很快完成 Diff 并避免重复渲染的问题。</li></ol> <h3 id="react-性能优化"><a href="#react-性能优化" class="header-anchor">#</a> React 性能优化</h3> <ol><li><p><code>props/state</code> 新旧值的变化来决定是否渲染组件。</p> <p>React 可以通过 <code>shouldComponentUpdate</code>, <code>PureComponent</code>, <code>React.memo</code> 来对组件渲染进行性能优化。</p> <p><code>shouldComponentUpdate</code> 是 class 组件生命周期中的一个钩子，常用于 <code>component</code> 中。</p> <p>该钩子的返回值可以决定组件是否进行渲染，如果没有在组件内定义该钩子的逻辑，则默认返回 <code>true</code>, 这也就意味着 React 默认情况下是无条件渲染的。通常 <code>component</code> 组件可以通过该钩子对比数据，以决定组件是否该渲染，从而避免重复渲染的问题。</p> <blockquote><p>值得注意的是，即便在 <code>shouldComponentUpdate</code> 对新旧 props 使用深对比也不能破坏 React <strong>不可变值****不可变值</strong>原值。
因为直接改变 state 的数据再通过 setState 来更新数据，因为新旧数据的值是一致的(旧数据被修改)，也就不能触发渲染。</p></blockquote></li> <li><p>列表渲染时每项添加唯一的 <code>key</code>。</p></li> <li><p>定时器、DOM 事件等在组件销毁时一同销毁，从而避免内存泄露。</p></li> <li><p>代码分割，使用异步组件。</p></li> <li><p>Hooks 使用 <code>useMemo</code> 缓存上一次计算的结果，避免重复计算值。</p></li></ol> <h3 id="父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免"><a href="#父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免" class="header-anchor">#</a> 父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？</h3> <p>如果父组件渲染后，子组件接收的 props 也跟着发生了改变，那么默认情况下会触发子组件的渲染。</p> <p>若子组件接受的 props 没有发生改变，那就得判断子组件的状况。</p> <p>如果子组件是继承于 <code>component</code> 声明的组件，并且没有使用 <code>shouldComponentUpdate</code> 做避免重复渲染的处理，那么子组件会触发 render 事件。</p> <p>为了避免重复渲染，类组件可以使用 <code>shouldComponentUpdate</code> 来决定是否进行渲染。也可以将继承于 <code>component</code> 组件改为继承 <code>PureComponment</code>，该组件会浅对比 <code>Props</code> 是否进行改变，从而决定是否渲染组件。</p> <p>如果是函数组件，可以通过 <code>React.memo</code> 来对函数组件进行缓存。</p> <blockquote><p>问题本质上想问 React 性能优化的问题，可以参考上题答案。</p></blockquote> <h3 id="异步组件怎么使用"><a href="#异步组件怎么使用" class="header-anchor">#</a> 异步组件怎么使用？</h3> <ol><li><p>通过动态 <code>import()</code> 语法对组件代码进行分割。</p></li> <li><p>使用 <code>React.lazy</code> 函数，结合 <code>import()</code> 语法引入动态组件。在组件首次渲染时，会自动导入包含 <code>MyComponent</code> 的包。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./MyComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>在 <code>React.Suspense</code> 组件中渲染 <code>lazy</code> 组件，同时可以使用 <code>fallback</code> 做优雅降级(添加 <code>loading</code> 效果):</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Loading...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Suspense</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>封装一个错误捕获组件(比如组件命名为 <code>MyErrorBoundary</code>)，组件内通过生命周期 <code>getDerivedStateFromError</code> 捕获错误信息。当异步组件加载失败时，将捕获到错误信息处理后给用户做错误提示功能。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyErrorBoundary</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Loading...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Suspense</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">MyErrorBoundary</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol> <h3 id="jsx-是如何编译为-js-代码的"><a href="#jsx-是如何编译为-js-代码的" class="header-anchor">#</a> JSX 是如何编译为 js 代码的？</h3> <p>在 React v17 之前，JSX 会被编译为 <code>React.createElement(component, props, ...children)</code> 函数，执行会返回 <code>vnode</code>，<code>vnode</code> 通过 <code>patch</code> 之类的方法渲染到页面。</p> <p>React v17 之后更新了 JSX 转换规则。新的 JSX 转换不会将 JSX 转换为 <code>React.createElement</code>，而是自动从 React 的 <code>package</code> 中引入新的入口函数(<code>react/jsx-runtime</code>)并调用。这意味着我们不用在每个组件文件中显式引入 <code>React</code>。</p> <h3 id="hooks-相比-class-的优点"><a href="#hooks-相比-class-的优点" class="header-anchor">#</a> Hooks 相比 class 的优点</h3> <p>类组件的不足:</p> <ul><li>状态逻辑复用难，缺少复用机制。渲染属性和高阶组件导致层级冗余</li> <li>复杂组件变得难以理解</li> <li>this 指向困扰</li></ul> <p>Hooks 的优点:</p> <ul><li>自定义 Hook 方便复用状态逻辑</li> <li>副作用的关注点分离</li> <li>函数组件没有 this 问题</li></ul> <p>Hooks 现有的不足:</p> <ul><li>不能完全代替 class 组件的生命周期，部分不常用的生命周期暂时没有实现</li> <li>useEffect 等 Hook 的运作方式带来了一定的学习成本，需要转换现有的编程思维</li></ul> <h3 id="hooks-的使用"><a href="#hooks-的使用" class="header-anchor">#</a> Hooks 的使用</h3> <blockquote><p>描述 Hooks 有哪些方法和大致用途</p></blockquote> <ol><li><p><code>useState</code>: 使函数组件支持设置 <code>state</code> 数据，可用于代替类组件的 <code>constructor</code> 函数。</p></li> <li><p><code>useEffect</code>: 使函数组件支持操作副作用的能力，可以模拟类组件 <code>componentDidMount</code> 的功能。同时还能监听数据变化，进而操作一系列诸如数据获取等副作用操作。 可以在 <code>useEffect</code> 的函数中返回一个函数做清除操作。这个清除操作时可选的:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一个参数是函数</span>
<span class="token comment">// 第二个参数是函数内所依赖的外部变量数组。若没有外部依赖，则可以忽略第二个参数。</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// useEffect 回调函数的返回值是函数的话，当组件卸载时会执行该函数</span>
   <span class="token comment">// 若没有需要清除的东西，则可以忽略这一步骤</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>handleClick<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>useContext</code>: 接收一个 <code>Context</code> 对象，并返回 <code>Context</code> 的当前值。相当于类组件的 <code>static contextType = MyContext</code>。</p></li> <li><p><code>useReducer</code> 是 <code>useState</code> 的代替方案，有点类似于 <code>redux</code> 的工作方式。它通过函数来操作 state，适合 state 逻辑较为复杂且包含多个子值，或是下一个 state 依赖于旧的 state 的场景。</p></li> <li><p><code>useMemo</code> 可以缓存变量的值，避免每次组件更新后都需要重复计算值。</p></li> <li><p><code>useCallbck</code> 用于缓存函数，避免函数被重复创建。它是 <code>useMemo</code> 的语法糖，<code>useCallback(fn, deps)</code> 相当于是 <code>useMemo(() =&gt; fn, deps)</code>。</p></li></ol> <h3 id="自定义-hook-怎么使用"><a href="#自定义-hook-怎么使用" class="header-anchor">#</a> 自定义 Hook 怎么使用</h3> <p>自定义 Hook 的命名规则是以 <code>use</code> 开头的函数，比如 <code>useLocalStorage</code> 就符合自定义 Hook 的命名规范。
使用自定义 Hook 的场景有很多，如表单处理、动画、订阅声明、定时器等等可复用的逻辑都能通过自定义 Hook 来抽象实现。</p> <p>在自定义 Hook 中，可以使用 Hooks 函数将可复用的逻辑和功能提取出来，并将内部的 <code>state</code> 或操作的方法从自定义 Hook 函数中返回出来。函数组件使用时就可以像调用普通函数一祥调用自定义 Hook 函数, 并将自定义 Hook 返回的 <code>state</code> 和操作方法通过解构保存到变量中。</p> <p>下面是 <a href="https://usehooks.com/useLocalStorage/" target="_blank" rel="noopener noreferrer">useLocalStorage<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的实现，它将 state 同步到本地存储，以使其在页面刷新后保持不变。 用法与 useState 相似，不同之处在于我们传入了本地存储键，以便我们可以在页面加载时默认为该值，而不是指定的初始值。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// Usage</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Similar to useState but first arg is key to the value in local storage.</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useLocalStorage</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
        <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span>
        <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Enter your name<span class="token punctuation">&quot;</span></span>
        <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span>
        <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token function">setName</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span>
      <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hook</span>
<span class="token keyword">function</span> <span class="token function">useLocalStorage</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> initialValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// State to store our value</span>
  <span class="token comment">// Pass initial state function to useState so logic is only executed once</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>storedValue<span class="token punctuation">,</span> setStoredValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// Get from local storage by key</span>
      <span class="token keyword">const</span> item <span class="token operator">=</span> window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Parse stored json or if none return initialValue</span>
      <span class="token keyword">return</span> item <span class="token operator">?</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> initialValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// If error also return initialValue</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> initialValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Return a wrapped version of useState's setter function that ...</span>
  <span class="token comment">// ... persists the new value to localStorage.</span>
  <span class="token keyword">const</span> <span class="token function-variable function">setValue</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// Allow value to be a function so we have same API as useState</span>
      <span class="token keyword">const</span> valueToStore <span class="token operator">=</span>
        value <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">(</span>storedValue<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">;</span>
      <span class="token comment">// Save state</span>
      <span class="token function">setStoredValue</span><span class="token punctuation">(</span>valueToStore<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Save to local storage</span>
      window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>valueToStore<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// A more advanced implementation would handle the error case</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>storedValue<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意: 自定义 Hook 函数在定义时，也可以使用另一个自定义 Hook 函数。</strong></p> <h3 id="hook-使用约束"><a href="#hook-使用约束" class="header-anchor">#</a> Hook 使用约束</h3> <ol><li>只能在<strong>函数组件最顶层</strong>调用 Hook，不能在循环、条件判断或子函数中调用。</li> <li>只能在<strong>函数组件</strong>或者是<strong>自定义 Hook 函数</strong>中调用，普通的 js 函数不能使用。</li></ol> <h3 id="hooks-怎么实现-class-组件的功能"><a href="#hooks-怎么实现-class-组件的功能" class="header-anchor">#</a> Hooks 怎么实现 class 组件的功能</h3> <p>Hooks 没有生命周期，但可以通过 Hook 来模拟生命周期的功能。</p> <h4 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor</h4> <p>class 组件的构造函数一般是用于设置 state 或者给事件绑定 this 的。Hooks 中没有 this 指向的问题，而 state 可以通过 <code>useState</code>/<code>useReducer</code> 来实现。</p> <h4 id="getderivedstatefromprops"><a href="#getderivedstatefromprops" class="header-anchor">#</a> getDerivedStateFromProps</h4> <p><code>getDerivedStateFromProps</code> 用于在组件 props 变化时派生 <code>state</code>。可以通过 Hook 这样实现:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ScrollView</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> row <span class="token operator">&gt;</span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Scrolling down: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="shouldcomponentupdate"><a href="#shouldcomponentupdate" class="header-anchor">#</a> shouldComponentUpdate</h4> <p><code>shouldComponentUpdate</code> 可以根据 <code>props</code>/<code>state</code> 的新旧值变化决定是否更新组件，在函数组件中可以使用 <code>React.memo</code> 达到同样的效果。</p> <p><code>React.memo</code> 默认只是浅比较 <code>props</code> 的变化，它的第一个参数是函数组件，第二个参数是可选的自定义比较函数，用于来比较新旧 <code>props</code>。</p> <h4 id="hooks-没有实现的生命周期钩子"><a href="#hooks-没有实现的生命周期钩子" class="header-anchor">#</a> Hooks 没有实现的生命周期钩子</h4> <ul><li>getSnapshotBeforeUpdate</li> <li>getDerivedStateFromError</li> <li>componentDidCatch</li></ul> <h4 id="如何强制更新-hook-组件"><a href="#如何强制更新-hook-组件" class="header-anchor">#</a> 如何强制更新 Hook 组件?</h4> <p>可以设置一个<strong>没有实际作用</strong>的 <code>state</code>，然后强制更新 <code>state</code> 的值触发渲染。</p> <h4 id="类实例成员变量如何映射到-hooks"><a href="#类实例成员变量如何映射到-hooks" class="header-anchor">#</a> 类实例成员变量如何映射到 Hooks?</h4> <p>使用 <code>useRef</code> 设置可变数据。</p> <h4 id="hook-中如何获取旧的-props-和-state"><a href="#hook-中如何获取旧的-props-和-state" class="header-anchor">#</a> Hook 中如何获取旧的 props 和 state</h4> <p>可以通过 <code>useRef</code> 来保存数据，因为渲染时不会覆盖掉 ref。</p> <h3 id="有了解过-portals-吗"><a href="#有了解过-portals-吗" class="header-anchor">#</a> 有了解过 Portals 吗?</h3> <p><code>Portals</code> 就像个传送门，它可以将子节点渲染到存在于父组件以外的 DOM 节点的方案。</p> <p>比如 <code>Dialog</code> 是一个全局组件，按照传统渲染组件的方式，<code>Dialog</code> 可能会受到其容器 css 的影响。因此可以使用 <code>Portals</code> 让组件在视觉上渲染到 <code>&lt;body&gt;</code> 中，使其样式不受 <code>overflow: hidden</code> 或 <code>z-index</code> 的影响。</p> <h3 id="怎么对组件的参数做类型约束呢"><a href="#怎么对组件的参数做类型约束呢" class="header-anchor">#</a> 怎么对组件的参数做类型约束呢?</h3> <p>要对组件的参数做类型约束的话，可以引入 <code>prop-types</code> 来配置对应的 <code>propTypes</code> 属性。<br> <code>Flow</code> 和 <code>TypesScript</code> 则可以对整个应用做类型检查。</p> <h3 id="组件设计原则"><a href="#组件设计原则" class="header-anchor">#</a> 组件设计原则</h3> <ul><li>从功能上拆分组件</li> <li>组件功能原子化</li> <li>容器组件只管数据，UI 组件只管视图</li> <li>可复用、易用、直观。</li> <li>组件库可以遵循 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles" target="_blank" rel="noopener noreferrer">ARIA<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>规范</li></ul> <h3 id="redux是什么-它遵循什么原则吗"><a href="#redux是什么-它遵循什么原则吗" class="header-anchor">#</a> redux是什么? 它遵循什么原则吗?</h3> <p>Redux 是状态容器与数据流管理。它的三大原则是:单一数据源、状态不可变、纯函数(无副作用函数)修改状态。</p> <h3 id="描述-redux-单向数据流"><a href="#描述-redux-单向数据流" class="header-anchor">#</a> 描述 redux 单向数据流</h3> <ol><li>Redux 内部维护一个 <code>state</code> 数据。这个 <code>state</code> 数据只能通过 <code>dispatch</code> 派生 <code>action</code> 事件才能修改。</li> <li>若 Redux 使用了中间件，先经过全部中间件处理</li> <li><code>dispatch</code> 触发事件后将 <code>action</code> 事件和当前的 <code>state</code> 数据传入给 <code>reducer</code>，由 <code>reducer</code> 对事件进行处理并返回更新后 <code>state</code> 数据。</li> <li><code>reducer</code> 的返回值将用于更新 <code>state</code> 数据</li> <li>如果需要获取 <code>state</code> 更新后的数据，可以调用 <code>subscribe</code> 方法，传递一个监听函数来订阅数据的变化。当数据更新后将会调用每个监听函数。
6.将获取到的 <code>state</code> 数据渲染到视图中</li></ol> <h2 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h2> <h3 id="列举-vue-的生命周期以及它们的应用场景"><a href="#列举-vue-的生命周期以及它们的应用场景" class="header-anchor">#</a> 列举 Vue 的生命周期以及它们的应用场景</h3> <p>Vue 的生命周期可以分为<strong>挂载阶段</strong>、<strong>更新阶段</strong>、<strong>销毁阶段</strong>三大阶段。</p> <p>TODO: 待补充...</p> <h3 id="父组件和子组件生命周期钩子执行顺序是什么"><a href="#父组件和子组件生命周期钩子执行顺序是什么" class="header-anchor">#</a> 父组件和子组件生命周期钩子执行顺序是什么？</h3> <p>TODO: 待补充...</p> <h3 id="dom-渲染在-vue-的哪个生命周期就已经完成"><a href="#dom-渲染在-vue-的哪个生命周期就已经完成" class="header-anchor">#</a> DOM 渲染在 Vue 的哪个生命周期就已经完成</h3> <p><code>mounted</code> 就已经被挂载。</p> <h3 id="v-for-遍历模板时为什么要用-key-key-有什么用"><a href="#v-for-遍历模板时为什么要用-key-key-有什么用" class="header-anchor">#</a> v-for 遍历模板时为什么要用 key? key 有什么用？</h3> <p>必须要用 key，因为当列表刷新时，底层的虚拟 DOM 会使用 diff 算法来对比新旧 DOM 树的变化。它首先是比对同一层级的 <code>tag</code> 和 <code>key</code> 来判断是否是同一个节点(sameNode)，若同一个层级的列表项都设有唯一的 key 的话，那就可以避免重复渲染的问题，从而提升渲染性能。</p> <h3 id="v-if-与-v-show-有什么区别-在什么场景下可以应用"><a href="#v-if-与-v-show-有什么区别-在什么场景下可以应用" class="header-anchor">#</a> v-if 与 v-show 有什么区别? 在什么场景下可以应用</h3> <p>主要取决于元素是否会多次渲染，<code>v-if</code> 决定节点是否渲染，<code>v-show</code> 会渲染节点，但会通过 <code>display</code> 控制是否展示。</p> <p>如果仅需渲染一次的话可以使用 <code>v-if</code>。反之，如果需要频繁渲染的话可以使用 <code>v-show</code> 仅展示显隐。</p> <h3 id="vue-组件通信"><a href="#vue-组件通信" class="header-anchor">#</a> vue 组件通信</h3> <ul><li><p>父子通信中，父组件通过 <code>props</code> 传值给子组件并监听子组件对应的事件，子组件通过 <code>emit</code> 触发事件，</p></li> <li><p>通过 vue 自定义事件进行父子/跨组件通信</p> <p>详细的操作是： 先新建一个 <code>event.js</code> 文件，该文件将导出一个新的 <code>Vue</code> 实例，通过该实例进行收发事件。<br>
如果在组件中使用 <code>event</code> 监听了事件，那应该在组件销毁时，也就是 <code>beforeDestroy</code> 中销毁该事件。</p></li> <li><p><code>vuex</code></p></li></ul> <h3 id="vue-的双向绑定原理是什么"><a href="#vue-的双向绑定原理是什么" class="header-anchor">#</a> vue 的双向绑定原理是什么？</h3> <p>数据劫持，get set 发布者与订阅者</p> <p>TODO: 待补充...</p> <h3 id="怎么在组件中实现-v-modal"><a href="#怎么在组件中实现-v-modal" class="header-anchor">#</a> 怎么在组件中实现 v-modal</h3> <p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件(<code>event</code>)完成双向绑定。当 data 更新会触发 re-render.</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token comment">&lt;!-- 等同于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$event.target.value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model" target="_blank" rel="noopener noreferrer">自定义组件的 v-model<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="beforedestroy-一般的用途"><a href="#beforedestroy-一般的用途" class="header-anchor">#</a> beforeDestroy 一般的用途</h3> <ul><li>解除自定义事件</li> <li>消除定时器</li> <li>解绑自定义的 DOM 事件监听器</li></ul> <h3 id="vue-router-的-beforeeach-和-aftereach-一般用法-使用场景"><a href="#vue-router-的-beforeeach-和-aftereach-一般用法-使用场景" class="header-anchor">#</a> vue router 的 beforeEach 和 afterEach 一般用法/使用场景?</h3> <p>TODO: 待补充...</p> <h3 id="虚拟-dom"><a href="#虚拟-dom" class="header-anchor">#</a> 虚拟 DOM</h3> <p>因为 DOM 操作会非常耗费性能，因此引入了虚拟 DOM 来检查对 DOM 的操作。</p> <p>引入虚拟 DOM 后，开发方式也发生了改变。以前需要手动操作 DOM，现在只需要关心数据的变化，由数据驱动视图。</p> <p>虚拟 DOM 主要是指 <code>vdom</code>, 它用 js 生成 DOM 树来模拟 DOM 结构，计算出最小的变更来操作 dom。</p> <p>计算最小的变更是通过 <code>diff 算法</code> 来实现的，它也是 vdom 中最核心、最关键的部分。vdom diff 其实 diff 新旧树的变化。</p> <h3 id="vdom-diff-特点"><a href="#vdom-diff-特点" class="header-anchor">#</a> vdom diff 特点</h3> <ul><li>vdom diff 只 diff 同一层，不跨级比较</li> <li>tag 不相同，则直接丢掉重建，不再深度比较</li> <li>tag 和 key，两者都相同，则认为是相同节点，不再深度比较</li></ul> <h3 id="vdom-diff-算法的事件复杂度"><a href="#vdom-diff-算法的事件复杂度" class="header-anchor">#</a> vdom diff 算法的事件复杂度</h3> <p>在 <code>O(n^3)</code> 的基础上使用了同层比较策略，因此优化为 <code>O(n)</code>.</p> <h3 id="vue-性能优化"><a href="#vue-性能优化" class="header-anchor">#</a> vue 性能优化</h3> <p>在使用层面上需要注意以下几点:</p> <ul><li>根据业务场景合理的使用 <code>v-if</code> 和 <code>v-show</code></li> <li>合理使用 <code>computed</code></li> <li><code>v-for</code> 循环时加上唯一的 <code>key</code>, 避免和 <code>v-if</code> 同时使用</li> <li>在组件内创建的自定义事件、DOM 事件监听器在组件销毁前要销毁，避免内存泄露。</li> <li>根据业务场景合理使用 <code>keep-alive</code></li> <li>data 层级不易过深</li></ul> <h2 id="vue-与-react-的区别"><a href="#vue-与-react-的区别" class="header-anchor">#</a> Vue 与 React 的区别</h2> <blockquote><p>如果候选者 vue 和 react 都开发过项目的话，面试官可能会问两者的差别，技术选型的理由</p></blockquote> <ol><li>在语法层面上 React 使用 JSX，Vue 使用模板。</li> <li>在编程思想上，React 是函数式编程，vue 是声明式编程</li> <li>React 相比 vue 会更精简，同时学习成本会更高一些。vue 的语法糖和封装程度比 React 高。比如 vue 原生的 <code>watch</code>、<code>keep-alive</code> 等功能都需要 React 用户自己去实现，而 <code>vue</code> 可以只关注使用。</li></ol> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h2> <h3 id="module、chunk、bundle-分别是什么"><a href="#module、chunk、bundle-分别是什么" class="header-anchor">#</a> module、chunk、bundle 分别是什么？</h3> <p>TODO: 待补充...</p> <h3 id="loader-和-plugin-有什么区别-有自己实现过吗"><a href="#loader-和-plugin-有什么区别-有自己实现过吗" class="header-anchor">#</a> loader 和 plugin 有什么区别？有自己实现过吗？</h3> <p>TODO: 待补充...</p> <h3 id="除了做基础脚手架外-还用来做过什么"><a href="#除了做基础脚手架外-还用来做过什么" class="header-anchor">#</a> 除了做基础脚手架外，还用来做过什么?</h3> <p>TODO: 待补充...</p> <h3 id="webpack-实现懒加载"><a href="#webpack-实现懒加载" class="header-anchor">#</a> webpack 实现懒加载</h3> <p>TODO: 待补充...</p> <h3 id="webpack-优化项"><a href="#webpack-优化项" class="header-anchor">#</a> webpack 优化项</h3> <p>TODO: 待补充...</p> <h3 id="babel-runtime-和-babel-polyfill"><a href="#babel-runtime-和-babel-polyfill" class="header-anchor">#</a> babel-runtime 和 babel-polyfill</h3> <p>TODO: 待补充...</p> <h3 id="什么是-tree-shaking"><a href="#什么是-tree-shaking" class="header-anchor">#</a> 什么是 Tree-Shaking</h3> <p>TODO: 待补充...</p> <h3 id="rollup-和-webpack-有什么区别"><a href="#rollup-和-webpack-有什么区别" class="header-anchor">#</a> rollup 和 webpack 有什么区别？</h3> <p>Rollup 主要专注打包，打包后 size 会非常小。webpack 功能多而杂但过于复杂。</p> <h2 id="优化类"><a href="#优化类" class="header-anchor">#</a> 优化类</h2> <h3 id="spa-vue-react-如何优化首页的加载速度-首屏空白是什么问题引起的"><a href="#spa-vue-react-如何优化首页的加载速度-首屏空白是什么问题引起的" class="header-anchor">#</a> SPA（vue/react） 如何优化首页的加载速度？首屏空白是什么问题引起的？</h3> <p>最佳解决方案是使用服务端渲染来解决首屏空白的问题</p> <p>TODO: 待补充...</p> <h3 id="页面性能优化有哪些方案"><a href="#页面性能优化有哪些方案" class="header-anchor">#</a> 页面性能优化有哪些方案？</h3> <ol><li><p>尽可能减少 HTTP 请求：</p> <p>CSS spirit 合并图片，小文件转为 Base64，合并 css/javascript 文件。</p></li> <li><p>使用CDN：CDN就是内容分发网络, 简单地说就是用户可以从最优的节点获取速度，从而达到快速访问，并减少源站负载压力的目的。</p></li></ol> <p>TODO: 待补充...</p> <h2 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h2> <h3 id="列举移动端适配方案"><a href="#列举移动端适配方案" class="header-anchor">#</a> 列举移动端适配方案</h3> <ol><li><code>rem</code></li> <li><code>vw</code>/<code>vh</code></li></ol> <p>TODO: 待补充...</p> <h3 id="怎么处理跨域"><a href="#怎么处理跨域" class="header-anchor">#</a> 怎么处理跨域？</h3> <p>TODO: 待补充...</p> <h2 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h2> <h3 id="列举-http-状态码以及它们的含义"><a href="#列举-http-状态码以及它们的含义" class="header-anchor">#</a> 列举 HTTP 状态码以及它们的含义</h3> <p>TODO: 待补充...</p> <h3 id="http-的-get-和-post-请求有什么区别"><a href="#http-的-get-和-post-请求有什么区别" class="header-anchor">#</a> HTTP 的 GET 和 POST 请求有什么区别？</h3> <p>GET 和 POST 在浏览器上的表现会根据使用场景有各自的优缺点:</p> <ul><li>GET 可以直接在浏览器上手动输入请求，在浏览器地址直接请求的 URL 在非匿名模式下会被浏览器记录下来的。这样用户可以通过历史记录来找回之前访问过的页面。反之，POST 不会在浏览器留下痕迹。</li> <li>GET 在浏览器地址上的长度是有限制的，POST 没有限制。</li> <li>GET 的请求一般可以被浏览器缓存</li> <li>带云压缩的浏览器，比如 Opera mini/Turbo 2, 只有 GET 才能在服务器端被预取</li></ul> <p>但实际使用时 GET 和 POST 请求所进行的操作取决于服务端是如何解释的。比如一种极端情况就是：不管你是查询、删除、更新还是提交数据也好，所有请求一律使用 POST 来实现都没问题。但这种做法不符合主流的 <code>RESTful APIs</code> 设计规范，不建议这样做。</p> <p>相关讨论参见: <a href="https://www.zhihu.com/question/31640769?rf=37401322" target="_blank" rel="noopener noreferrer">post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="http-握手过程"><a href="#http-握手过程" class="header-anchor">#</a> HTTP 握手过程</h3> <p>TODO: 待补充...</p> <h3 id="有了解过-http-缓存吗"><a href="#有了解过-http-缓存吗" class="header-anchor">#</a> 有了解过 HTTP 缓存吗？</h3> <p>主要是指强缓存与协商缓存。</p> <p>TODO: 待补充区别...</p> <h2 id="运维相关"><a href="#运维相关" class="header-anchor">#</a> 运维相关</h2> <ol><li><p>了解过 docker 吗？</p></li> <li><p>你们项目的 CI/CD 是怎么搭建的？</p></li> <li><p>阿里云的 CDN 资源有缓存，如何强制更新缓存?</p> <p>阿里云 CDN 中有一个 Tab 叫<strong>刷新预热</strong>, 在该选项中可以强制刷新缓存。更新缓存的方式有 <strong>URL 刷新</strong>、<strong>目录刷新</strong>以及 <strong>URL 预热</strong>。</p></li> <li><p>git 除了 <code>pull</code>、<code>push</code> 外还了解哪些命令？</p> <p>可以参考 <a href="/front-end-lab/git/">Git 速查笔记</a></p></li></ol> <h2 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h2> <ol><li>你哪些项目实现的比较满意？</li> <li>你碰到最难的一个问题是什么？</li> <li>是否写过测试用例</li> <li>是否了解敏捷开发</li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/anran758/front-end-lab/edit/master/docs/topic/2020.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2020/12/16 上午3:59:44</span></div></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/front-end-lab/assets/js/app.e02e37a4.js" defer></script><script src="/front-end-lab/assets/js/2.9a3fe56a.js" defer></script><script src="/front-end-lab/assets/js/22.199b8985.js" defer></script><script src="/front-end-lab/assets/js/4.88b13e9f.js" defer></script>
  </body>
</html>
